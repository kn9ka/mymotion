"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./shared/lib/webgl.js":
/*!*****************************!*\
  !*** ./shared/lib/webgl.js ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\nMIT License\nCopyright (c) 2017 Pavel Dobryakov\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/ \n// Simulation section\nlet document = window.document;\nconst canvas = document.getElementById(\"smoke-webgl\")[0];\nconsole.log(canvas);\nresizeCanvas();\nlet config = {\n    SIM_RESOLUTION: 128,\n    DYE_RESOLUTION: 1024,\n    CAPTURE_RESOLUTION: 512,\n    DENSITY_DISSIPATION: 1,\n    VELOCITY_DISSIPATION: 0.2,\n    PRESSURE: 0.8,\n    PRESSURE_ITERATIONS: 20,\n    CURL: 30,\n    SPLAT_RADIUS: 0.25,\n    SPLAT_FORCE: 6000,\n    SHADING: true,\n    COLORFUL: true,\n    COLOR_UPDATE_SPEED: 10,\n    PAUSED: false,\n    BACK_COLOR: {\n        r: 0,\n        g: 0,\n        b: 0\n    },\n    TRANSPARENT: false,\n    BLOOM: true,\n    BLOOM_ITERATIONS: 8,\n    BLOOM_RESOLUTION: 256,\n    BLOOM_INTENSITY: 0.8,\n    BLOOM_THRESHOLD: 0.6,\n    BLOOM_SOFT_KNEE: 0.7,\n    SUNRAYS: true,\n    SUNRAYS_RESOLUTION: 196,\n    SUNRAYS_WEIGHT: 1.0\n};\nfunction pointerPrototype() {\n    this.id = -1;\n    this.texcoordX = 0;\n    this.texcoordY = 0;\n    this.prevTexcoordX = 0;\n    this.prevTexcoordY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.down = false;\n    this.moved = false;\n    this.color = [\n        30,\n        0,\n        300\n    ];\n}\nlet pointers = [];\nlet splatStack = [];\npointers.push(new pointerPrototype());\nconst { gl , ext  } = getWebGLContext(canvas);\nif (isMobile()) {\n    config.DYE_RESOLUTION = 512;\n}\nif (!ext.supportLinearFiltering) {\n    config.DYE_RESOLUTION = 512;\n    config.SHADING = false;\n    config.BLOOM = false;\n    config.SUNRAYS = false;\n}\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n    let halfFloat;\n    let supportLinearFiltering;\n    if (isWebGL2) {\n        gl.getExtension(\"EXT_color_buffer_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n    } else {\n        halfFloat = gl.getExtension(\"OES_texture_half_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_half_float_linear\");\n    }\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;\n    let formatRGBA;\n    let formatRG;\n    let formatR;\n    if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n    } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    }\n    return {\n        gl,\n        ext: {\n            formatRGBA,\n            formatRG,\n            formatR,\n            halfFloatTexType,\n            supportLinearFiltering\n        }\n    };\n}\nfunction getSupportedFormat(gl, internalFormat, format, type) {\n    if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch(internalFormat){\n            case gl.R16F:\n                return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n            case gl.RG16F:\n                return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n            default:\n                return null;\n        }\n    }\n    return {\n        internalFormat,\n        format\n    };\n}\nfunction supportRenderTextureFormat(gl, internalFormat, format, type) {\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    return status == gl.FRAMEBUFFER_COMPLETE;\n}\nfunction isMobile() {\n    return /Mobi|Android/i.test(navigator.userAgent);\n}\nfunction captureScreenshot() {\n    let res = getResolution(config.CAPTURE_RESOLUTION);\n    let target = createFBO(res.width, res.height, ext.formatRGBA.internalFormat, ext.formatRGBA.format, ext.halfFloatTexType, gl.NEAREST);\n    render(target);\n    let texture = framebufferToTexture(target);\n    texture = normalizeTexture(texture, target.width, target.height);\n    let captureCanvas = textureToCanvas(texture, target.width, target.height);\n    let datauri = captureCanvas.toDataURL();\n    downloadURI(\"fluid.png\", datauri);\n    URL.revokeObjectURL(datauri);\n}\nfunction framebufferToTexture(target) {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n    let length = target.width * target.height * 4;\n    let texture = new Float32Array(length);\n    gl.readPixels(0, 0, target.width, target.height, gl.RGBA, gl.FLOAT, texture);\n    return texture;\n}\nfunction normalizeTexture(texture, width, height) {\n    let result = new Uint8Array(texture.length);\n    let id = 0;\n    for(let i = height - 1; i >= 0; i--){\n        for(let j = 0; j < width; j++){\n            let nid = i * width * 4 + j * 4;\n            result[nid + 0] = clamp01(texture[id + 0]) * 255;\n            result[nid + 1] = clamp01(texture[id + 1]) * 255;\n            result[nid + 2] = clamp01(texture[id + 2]) * 255;\n            result[nid + 3] = clamp01(texture[id + 3]) * 255;\n            id += 4;\n        }\n    }\n    return result;\n}\nfunction clamp01(input) {\n    return Math.min(Math.max(input, 0), 1);\n}\nfunction textureToCanvas(texture, width, height) {\n    let captureCanvas = document.createElement(\"canvas\");\n    let ctx = captureCanvas.getContext(\"2d\");\n    captureCanvas.width = width;\n    captureCanvas.height = height;\n    let imageData = ctx.createImageData(width, height);\n    imageData.data.set(texture);\n    ctx.putImageData(imageData, 0, 0);\n    return captureCanvas;\n}\nfunction downloadURI(filename, uri) {\n    let link = document.createElement(\"a\");\n    link.download = filename;\n    link.href = uri;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\nclass Material {\n    setKeywords(keywords) {\n        let hash = 0;\n        for(let i = 0; i < keywords.length; i++)hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n            let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n            program = createProgram(this.vertexShader, fragmentShader);\n            this.programs[hash] = program;\n        }\n        if (program == this.activeProgram) return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n    }\n    bind() {\n        gl.useProgram(this.activeProgram);\n    }\n    constructor(vertexShader, fragmentShaderSource){\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = [];\n    }\n}\nclass Program {\n    bind() {\n        gl.useProgram(this.program);\n    }\n    constructor(vertexShader, fragmentShader){\n        this.uniforms = {};\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n    }\n}\nfunction createProgram(vertexShader, fragmentShader) {\n    let program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n    return program;\n}\nfunction getUniforms(program) {\n    let uniforms = [];\n    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for(let i = 0; i < uniformCount; i++){\n        let uniformName = gl.getActiveUniform(program, i).name;\n        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n    }\n    return uniforms;\n}\nfunction compileShader(type, source, keywords) {\n    source = addKeywords(source, keywords);\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n    return shader;\n}\nfunction addKeywords(source, keywords) {\n    if (keywords == null) return source;\n    let keywordsString = \"\";\n    keywords.forEach((keyword)=>{\n        keywordsString += \"#define \" + keyword + \"\\n\";\n    });\n    return keywordsString + source;\n}\nconst baseVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n    precision highp float;\\n    attribute vec2 aPosition;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform vec2 texelSize;\\n    void main () {\\n        vUv = aPosition * 0.5 + 0.5;\\n        vL = vUv - vec2(texelSize.x, 0.0);\\n        vR = vUv + vec2(texelSize.x, 0.0);\\n        vT = vUv + vec2(0.0, texelSize.y);\\n        vB = vUv - vec2(0.0, texelSize.y);\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n    }\\n\");\nconst blurVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n    precision highp float;\\n    attribute vec2 aPosition;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    uniform vec2 texelSize;\\n    void main () {\\n        vUv = aPosition * 0.5 + 0.5;\\n        float offset = 1.33333333;\\n        vL = vUv - texelSize * offset;\\n        vR = vUv + texelSize * offset;\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n    }\\n\");\nconst blurShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        vec4 sum = texture2D(uTexture, vUv) * 0.29411764;\\n        sum += texture2D(uTexture, vL) * 0.35294117;\\n        sum += texture2D(uTexture, vR) * 0.35294117;\\n        gl_FragColor = sum;\\n    }\\n\");\nconst copyShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        gl_FragColor = texture2D(uTexture, vUv);\\n    }\\n\");\nconst clearShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform float value;\\n    void main () {\\n        gl_FragColor = value * texture2D(uTexture, vUv);\\n    }\\n\");\nconst colorShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    uniform vec4 color;\\n    void main () {\\n        gl_FragColor = color;\\n    }\\n\");\nconst checkerboardShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform float aspectRatio;\\n    #define SCALE 25.0\\n    void main () {\\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\\n        float v = mod(uv.x + uv.y, 2.0);\\n        v = v * 0.1 + 0.8;\\n        gl_FragColor = vec4(vec3(v), 1.0);\\n    }\\n\");\nconst displayShaderSource = \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uTexture;\\n    uniform sampler2D uBloom;\\n    uniform sampler2D uSunrays;\\n    uniform sampler2D uDithering;\\n    uniform vec2 ditherScale;\\n    uniform vec2 texelSize;\\n    vec3 linearToGamma (vec3 color) {\\n        color = max(color, vec3(0));\\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n    }\\n    void main () {\\n        vec3 c = texture2D(uTexture, vUv).rgb;\\n    #ifdef SHADING\\n        vec3 lc = texture2D(uTexture, vL).rgb;\\n        vec3 rc = texture2D(uTexture, vR).rgb;\\n        vec3 tc = texture2D(uTexture, vT).rgb;\\n        vec3 bc = texture2D(uTexture, vB).rgb;\\n        float dx = length(rc) - length(lc);\\n        float dy = length(tc) - length(bc);\\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n        vec3 l = vec3(0.0, 0.0, 1.0);\\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n        c *= diffuse;\\n    #endif\\n    #ifdef BLOOM\\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\\n    #endif\\n    #ifdef SUNRAYS\\n        float sunrays = texture2D(uSunrays, vUv).r;\\n        c *= sunrays;\\n    #ifdef BLOOM\\n        bloom *= sunrays;\\n    #endif\\n    #endif\\n    #ifdef BLOOM\\n        float noise = texture2D(uDithering, vUv * ditherScale).r;\\n        noise = noise * 2.0 - 1.0;\\n        bloom += noise / 255.0;\\n        bloom = linearToGamma(bloom);\\n        c += bloom;\\n    #endif\\n        float a = max(c.r, max(c.g, c.b));\\n        gl_FragColor = vec4(c, a);\\n    }\\n\";\nconst bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform vec3 curve;\\n    uniform float threshold;\\n    void main () {\\n        vec3 c = texture2D(uTexture, vUv).rgb;\\n        float br = max(c.r, max(c.g, c.b));\\n        float rq = clamp(br - curve.x, 0.0, curve.y);\\n        rq = curve.z * rq * rq;\\n        c *= max(rq, br - threshold) / max(br, 0.0001);\\n        gl_FragColor = vec4(c, 0.0);\\n    }\\n\");\nconst bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        vec4 sum = vec4(0.0);\\n        sum += texture2D(uTexture, vL);\\n        sum += texture2D(uTexture, vR);\\n        sum += texture2D(uTexture, vT);\\n        sum += texture2D(uTexture, vB);\\n        sum *= 0.25;\\n        gl_FragColor = sum;\\n    }\\n\");\nconst bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uTexture;\\n    uniform float intensity;\\n    void main () {\\n        vec4 sum = vec4(0.0);\\n        sum += texture2D(uTexture, vL);\\n        sum += texture2D(uTexture, vR);\\n        sum += texture2D(uTexture, vT);\\n        sum += texture2D(uTexture, vB);\\n        sum *= 0.25;\\n        gl_FragColor = sum * intensity;\\n    }\\n\");\nconst sunraysMaskShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        vec4 c = texture2D(uTexture, vUv);\\n        float br = max(c.r, max(c.g, c.b));\\n        c.a = 1.0 - min(max(br * 20.0, 0.0), 0.8);\\n        gl_FragColor = c;\\n    }\\n\");\nconst sunraysShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform float weight;\\n    #define ITERATIONS 16\\n    void main () {\\n        float Density = 0.3;\\n        float Decay = 0.95;\\n        float Exposure = 0.7;\\n        vec2 coord = vUv;\\n        vec2 dir = vUv - 0.5;\\n        dir *= 1.0 / float(ITERATIONS) * Density;\\n        float illuminationDecay = 1.0;\\n        float color = texture2D(uTexture, vUv).a;\\n        for (int i = 0; i < ITERATIONS; i++)\\n        {\\n            coord -= dir;\\n            float col = texture2D(uTexture, coord).a;\\n            color += col * illuminationDecay * weight;\\n            illuminationDecay *= Decay;\\n        }\\n        gl_FragColor = vec4(color * Exposure, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst splatShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTarget;\\n    uniform float aspectRatio;\\n    uniform vec3 color;\\n    uniform vec2 point;\\n    uniform float radius;\\n    void main () {\\n        vec2 p = vUv - point.xy;\\n        p.x *= aspectRatio;\\n        vec3 splat = exp(-dot(p, p) / radius) * color;\\n        vec3 base = texture2D(uTarget, vUv).xyz;\\n        gl_FragColor = vec4(base + splat, 1.0);\\n    }\\n\");\nconst advectionShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uVelocity;\\n    uniform sampler2D uSource;\\n    uniform vec2 texelSize;\\n    uniform vec2 dyeTexelSize;\\n    uniform float dt;\\n    uniform float dissipation;\\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n        vec2 st = uv / tsize - 0.5;\\n        vec2 iuv = floor(st);\\n        vec2 fuv = fract(st);\\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n    }\\n    void main () {\\n    #ifdef MANUAL_FILTERING\\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n        vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n    #else\\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n        vec4 result = texture2D(uSource, coord);\\n    #endif\\n        float decay = 1.0 + dissipation * dt;\\n        gl_FragColor = result / decay;\\n    }\", ext.supportLinearFiltering ? null : [\n    \"MANUAL_FILTERING\"\n]);\nconst divergenceShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uVelocity;\\n    void main () {\\n        float L = texture2D(uVelocity, vL).x;\\n        float R = texture2D(uVelocity, vR).x;\\n        float T = texture2D(uVelocity, vT).y;\\n        float B = texture2D(uVelocity, vB).y;\\n        vec2 C = texture2D(uVelocity, vUv).xy;\\n        if (vL.x < 0.0) { L = -C.x; }\\n        if (vR.x > 1.0) { R = -C.x; }\\n        if (vT.y > 1.0) { T = -C.y; }\\n        if (vB.y < 0.0) { B = -C.y; }\\n        float div = 0.5 * (R - L + T - B);\\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst curlShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uVelocity;\\n    void main () {\\n        float L = texture2D(uVelocity, vL).y;\\n        float R = texture2D(uVelocity, vR).y;\\n        float T = texture2D(uVelocity, vT).x;\\n        float B = texture2D(uVelocity, vB).x;\\n        float vorticity = R - L - T + B;\\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst vorticityShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uVelocity;\\n    uniform sampler2D uCurl;\\n    uniform float curl;\\n    uniform float dt;\\n    void main () {\\n        float L = texture2D(uCurl, vL).x;\\n        float R = texture2D(uCurl, vR).x;\\n        float T = texture2D(uCurl, vT).x;\\n        float B = texture2D(uCurl, vB).x;\\n        float C = texture2D(uCurl, vUv).x;\\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n        force /= length(force) + 0.0001;\\n        force *= curl * C;\\n        force.y *= -1.0;\\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\\n        velocity += force * dt;\\n        velocity = min(max(velocity, -1000.0), 1000.0);\\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\\n    }\\n\");\nconst pressureShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uPressure;\\n    uniform sampler2D uDivergence;\\n    void main () {\\n        float L = texture2D(uPressure, vL).x;\\n        float R = texture2D(uPressure, vR).x;\\n        float T = texture2D(uPressure, vT).x;\\n        float B = texture2D(uPressure, vB).x;\\n        float C = texture2D(uPressure, vUv).x;\\n        float divergence = texture2D(uDivergence, vUv).x;\\n        float pressure = (L + R + B + T - divergence) * 0.25;\\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uPressure;\\n    uniform sampler2D uVelocity;\\n    void main () {\\n        float L = texture2D(uPressure, vL).x;\\n        float R = texture2D(uPressure, vR).x;\\n        float T = texture2D(uPressure, vT).x;\\n        float B = texture2D(uPressure, vB).x;\\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\\n        velocity.xy -= vec2(R - L, T - B);\\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\\n    }\\n\");\nconst blit = (()=>{\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1,\n        -1,\n        -1,\n        1,\n        1,\n        1,\n        1,\n        -1\n    ]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n        0,\n        1,\n        2,\n        0,\n        2,\n        3\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(0);\n    return function(target) {\n        let clear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (target == null) {\n            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n            gl.viewport(0, 0, target.width, target.height);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (clear) {\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        // CHECK_FRAMEBUFFER_STATUS();\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n})();\nfunction CHECK_FRAMEBUFFER_STATUS() {\n    let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status != gl.FRAMEBUFFER_COMPLETE) console.trace(\"Framebuffer error: \" + status);\n}\n_c = CHECK_FRAMEBUFFER_STATUS;\nlet dye;\nlet velocity;\nlet divergence;\nlet curl;\nlet pressure;\nlet bloom;\nlet bloomFramebuffers = [];\nlet sunrays;\nlet sunraysTemp;\nlet ditheringTexture = createTextureAsync(\"LDR_LLL1_0.png\");\nconst blurProgram = new Program(blurVertexShader, blurShader);\nconst copyProgram = new Program(baseVertexShader, copyShader);\nconst clearProgram = new Program(baseVertexShader, clearShader);\nconst colorProgram = new Program(baseVertexShader, colorShader);\nconst checkerboardProgram = new Program(baseVertexShader, checkerboardShader);\nconst bloomPrefilterProgram = new Program(baseVertexShader, bloomPrefilterShader);\nconst bloomBlurProgram = new Program(baseVertexShader, bloomBlurShader);\nconst bloomFinalProgram = new Program(baseVertexShader, bloomFinalShader);\nconst sunraysMaskProgram = new Program(baseVertexShader, sunraysMaskShader);\nconst sunraysProgram = new Program(baseVertexShader, sunraysShader);\nconst splatProgram = new Program(baseVertexShader, splatShader);\nconst advectionProgram = new Program(baseVertexShader, advectionShader);\nconst divergenceProgram = new Program(baseVertexShader, divergenceShader);\nconst curlProgram = new Program(baseVertexShader, curlShader);\nconst vorticityProgram = new Program(baseVertexShader, vorticityShader);\nconst pressureProgram = new Program(baseVertexShader, pressureShader);\nconst gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\nconst displayMaterial = new Material(baseVertexShader, displayShaderSource);\nfunction initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const rg = ext.formatRG;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    gl.disable(gl.BLEND);\n    if (dye == null) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n    else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n    if (velocity == null) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n    else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n    divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    initBloomFramebuffers();\n    initSunraysFramebuffers();\n}\nfunction initBloomFramebuffers() {\n    let res = getResolution(config.BLOOM_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    bloom = createFBO(res.width, res.height, rgba.internalFormat, rgba.format, texType, filtering);\n    bloomFramebuffers.length = 0;\n    for(let i = 0; i < config.BLOOM_ITERATIONS; i++){\n        let width = res.width >> i + 1;\n        let height = res.height >> i + 1;\n        if (width < 2 || height < 2) break;\n        let fbo = createFBO(width, height, rgba.internalFormat, rgba.format, texType, filtering);\n        bloomFramebuffers.push(fbo);\n    }\n}\nfunction initSunraysFramebuffers() {\n    let res = getResolution(config.SUNRAYS_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    sunrays = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);\n    sunraysTemp = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);\n}\nfunction createFBO(w, h, internalFormat, format, type, param) {\n    gl.activeTexture(gl.TEXTURE0);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    let texelSizeX = 1.0 / w;\n    let texelSizeY = 1.0 / h;\n    return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach (id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        }\n    };\n}\nfunction createDoubleFBO(w, h, internalFormat, format, type, param) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n    return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read () {\n            return fbo1;\n        },\n        set read (value){\n            fbo1 = value;\n        },\n        get write () {\n            return fbo2;\n        },\n        set write (value){\n            fbo2 = value;\n        },\n        swap () {\n            let temp = fbo1;\n            fbo1 = fbo2;\n            fbo2 = temp;\n        }\n    };\n}\nfunction resizeFBO(target, w, h, internalFormat, format, type, param) {\n    let newFBO = createFBO(w, h, internalFormat, format, type, param);\n    copyProgram.bind();\n    gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n    blit(newFBO);\n    return newFBO;\n}\nfunction resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n    if (target.width == w && target.height == h) return target;\n    target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n    target.write = createFBO(w, h, internalFormat, format, type, param);\n    target.width = w;\n    target.height = h;\n    target.texelSizeX = 1.0 / w;\n    target.texelSizeY = 1.0 / h;\n    return target;\n}\nfunction createTextureAsync(url) {\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([\n        255,\n        255,\n        255\n    ]));\n    let obj = {\n        texture,\n        width: 1,\n        height: 1,\n        attach (id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        }\n    };\n    let image = new Image();\n    image.onload = ()=>{\n        obj.width = image.width;\n        obj.height = image.height;\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n    };\n    image.src = url;\n    return obj;\n}\nfunction updateKeywords() {\n    let displayKeywords = [];\n    if (config.SHADING) displayKeywords.push(\"SHADING\");\n    if (config.BLOOM) displayKeywords.push(\"BLOOM\");\n    if (config.SUNRAYS) displayKeywords.push(\"SUNRAYS\");\n    displayMaterial.setKeywords(displayKeywords);\n}\nupdateKeywords();\ninitFramebuffers();\nmultipleSplats(parseInt(Math.random() * 20) + 5);\nlet lastUpdateTime = Date.now();\nlet colorUpdateTimer = 0.0;\nupdate();\nfunction update() {\n    const dt = calcDeltaTime();\n    if (resizeCanvas()) initFramebuffers();\n    updateColors(dt);\n    applyInputs();\n    if (!config.PAUSED) step(dt);\n    render(null);\n    requestAnimationFrame(update);\n}\nfunction calcDeltaTime() {\n    let now = Date.now();\n    let dt = (now - lastUpdateTime) / 1000;\n    dt = Math.min(dt, 0.016666);\n    lastUpdateTime = now;\n    return dt;\n}\nfunction resizeCanvas() {\n    let width = scaleByPixelRatio(canvas.clientWidth);\n    let height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\nfunction updateColors(dt) {\n    if (!config.COLORFUL) return;\n    colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n    if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach((p)=>{\n            p.color = generateColor();\n        });\n    }\n}\nfunction applyInputs() {\n    if (splatStack.length > 0) multipleSplats(splatStack.pop());\n    pointers.forEach((p)=>{\n        if (p.moved) {\n            p.moved = false;\n            splatPointer(p);\n        }\n    });\n}\nfunction step(dt) {\n    gl.disable(gl.BLEND);\n    curlProgram.bind();\n    gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n    blit(curl);\n    vorticityProgram.bind();\n    gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n    gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n    gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n    gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n    blit(velocity.write);\n    velocity.swap();\n    divergenceProgram.bind();\n    gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n    blit(divergence);\n    clearProgram.bind();\n    gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n    blit(pressure.write);\n    pressure.swap();\n    pressureProgram.bind();\n    gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n    for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        blit(pressure.write);\n        pressure.swap();\n    }\n    gradienSubtractProgram.bind();\n    gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n    gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n    blit(velocity.write);\n    velocity.swap();\n    advectionProgram.bind();\n    gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n    let velocityId = velocity.read.attach(0);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n    blit(velocity.write);\n    velocity.swap();\n    if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n    gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(dye.write);\n    dye.swap();\n}\nfunction render(target) {\n    if (config.BLOOM) applyBloom(dye.read, bloom);\n    if (config.SUNRAYS) {\n        applySunrays(dye.read, dye.write, sunrays);\n        blur(sunrays, sunraysTemp, 1);\n    }\n    if (target == null || !config.TRANSPARENT) {\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    } else {\n        gl.disable(gl.BLEND);\n    }\n    if (!config.TRANSPARENT) drawColor(target, normalizeColor(config.BACK_COLOR));\n    if (target == null && config.TRANSPARENT) drawCheckerboard(target);\n    drawDisplay(target);\n}\nfunction drawColor(target, color) {\n    colorProgram.bind();\n    gl.uniform4f(colorProgram.uniforms.color, color.r, color.g, color.b, 1);\n    blit(target);\n}\nfunction drawCheckerboard(target) {\n    checkerboardProgram.bind();\n    gl.uniform1f(checkerboardProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    blit(target);\n}\nfunction drawDisplay(target) {\n    let width = target == null ? gl.drawingBufferWidth : target.width;\n    let height = target == null ? gl.drawingBufferHeight : target.height;\n    displayMaterial.bind();\n    if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n    gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n    if (config.BLOOM) {\n        gl.uniform1i(displayMaterial.uniforms.uBloom, bloom.attach(1));\n        gl.uniform1i(displayMaterial.uniforms.uDithering, ditheringTexture.attach(2));\n        let scale = getTextureScale(ditheringTexture, width, height);\n        gl.uniform2f(displayMaterial.uniforms.ditherScale, scale.x, scale.y);\n    }\n    if (config.SUNRAYS) gl.uniform1i(displayMaterial.uniforms.uSunrays, sunrays.attach(3));\n    blit(target);\n}\nfunction applyBloom(source, destination) {\n    if (bloomFramebuffers.length < 2) return;\n    let last = destination;\n    gl.disable(gl.BLEND);\n    bloomPrefilterProgram.bind();\n    let knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;\n    let curve0 = config.BLOOM_THRESHOLD - knee;\n    let curve1 = knee * 2;\n    let curve2 = 0.25 / knee;\n    gl.uniform3f(bloomPrefilterProgram.uniforms.curve, curve0, curve1, curve2);\n    gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);\n    gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, source.attach(0));\n    blit(last);\n    bloomBlurProgram.bind();\n    for(let i = 0; i < bloomFramebuffers.length; i++){\n        let dest = bloomFramebuffers[i];\n        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n        blit(dest);\n        last = dest;\n    }\n    gl.blendFunc(gl.ONE, gl.ONE);\n    gl.enable(gl.BLEND);\n    for(let i1 = bloomFramebuffers.length - 2; i1 >= 0; i1--){\n        let baseTex = bloomFramebuffers[i1];\n        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n        gl.viewport(0, 0, baseTex.width, baseTex.height);\n        blit(baseTex);\n        last = baseTex;\n    }\n    gl.disable(gl.BLEND);\n    bloomFinalProgram.bind();\n    gl.uniform2f(bloomFinalProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n    gl.uniform1i(bloomFinalProgram.uniforms.uTexture, last.attach(0));\n    gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);\n    blit(destination);\n}\nfunction applySunrays(source, mask, destination) {\n    gl.disable(gl.BLEND);\n    sunraysMaskProgram.bind();\n    gl.uniform1i(sunraysMaskProgram.uniforms.uTexture, source.attach(0));\n    blit(mask);\n    sunraysProgram.bind();\n    gl.uniform1f(sunraysProgram.uniforms.weight, config.SUNRAYS_WEIGHT);\n    gl.uniform1i(sunraysProgram.uniforms.uTexture, mask.attach(0));\n    blit(destination);\n}\nfunction blur(target, temp, iterations) {\n    blurProgram.bind();\n    for(let i = 0; i < iterations; i++){\n        gl.uniform2f(blurProgram.uniforms.texelSize, target.texelSizeX, 0.0);\n        gl.uniform1i(blurProgram.uniforms.uTexture, target.attach(0));\n        blit(temp);\n        gl.uniform2f(blurProgram.uniforms.texelSize, 0.0, target.texelSizeY);\n        gl.uniform1i(blurProgram.uniforms.uTexture, temp.attach(0));\n        blit(target);\n    }\n}\nfunction splatPointer(pointer) {\n    let dx = pointer.deltaX * config.SPLAT_FORCE;\n    let dy = pointer.deltaY * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction multipleSplats(amount) {\n    for(let i = 0; i < amount; i++){\n        const color = generateColor();\n        color.r *= 10.0;\n        color.g *= 10.0;\n        color.b *= 10.0;\n        const x = Math.random();\n        const y = Math.random();\n        const dx = 1000 * (Math.random() - 0.5);\n        const dy = 1000 * (Math.random() - 0.5);\n        splat(x, y, dx, dy, color);\n    }\n}\nfunction splat(x, y, dx, dy, color) {\n    splatProgram.bind();\n    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x, y);\n    gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n    gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n    blit(velocity.write);\n    velocity.swap();\n    gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n    blit(dye.write);\n    dye.swap();\n}\nfunction correctRadius(radius) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) radius *= aspectRatio;\n    return radius;\n}\ncanvas.addEventListener(\"mousedown\", (e)=>{\n    let posX = scaleByPixelRatio(e.offsetX);\n    let posY = scaleByPixelRatio(e.offsetY);\n    let pointer = pointers.find((p)=>p.id == -1);\n    if (pointer == null) pointer = new pointerPrototype();\n    updatePointerDownData(pointer, -1, posX, posY);\n});\ncanvas.addEventListener(\"mousemove\", (e)=>{\n    let pointer = pointers[0];\n    if (!pointer.down) return;\n    let posX = scaleByPixelRatio(e.offsetX);\n    let posY = scaleByPixelRatio(e.offsetY);\n    updatePointerMoveData(pointer, posX, posY);\n});\nwindow.addEventListener(\"mouseup\", ()=>{\n    updatePointerUpData(pointers[0]);\n});\ncanvas.addEventListener(\"touchstart\", (e)=>{\n    e.preventDefault();\n    const touches = e.targetTouches;\n    while(touches.length >= pointers.length)pointers.push(new pointerPrototype());\n    for(let i = 0; i < touches.length; i++){\n        let posX = scaleByPixelRatio(touches[i].pageX);\n        let posY = scaleByPixelRatio(touches[i].pageY);\n        updatePointerDownData(pointers[i + 1], touches[i].identifier, posX, posY);\n    }\n});\ncanvas.addEventListener(\"touchmove\", (e)=>{\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for(let i = 0; i < touches.length; i++){\n        let pointer = pointers[i + 1];\n        if (!pointer.down) continue;\n        let posX = scaleByPixelRatio(touches[i].pageX);\n        let posY = scaleByPixelRatio(touches[i].pageY);\n        updatePointerMoveData(pointer, posX, posY);\n    }\n}, false);\nwindow.addEventListener(\"touchend\", (e)=>{\n    const touches = e.changedTouches;\n    for(let i = 0; i < touches.length; i++){\n        let pointer = pointers.find((p)=>p.id == touches[i].identifier);\n        if (pointer == null) continue;\n        updatePointerUpData(pointer);\n    }\n});\nwindow.addEventListener(\"keydown\", (e)=>{\n    if (e.code === \"KeyP\") config.PAUSED = !config.PAUSED;\n    if (e.key === \" \") splatStack.push(parseInt(Math.random() * 20) + 5);\n});\nfunction updatePointerDownData(pointer, id, posX, posY) {\n    pointer.id = id;\n    pointer.down = true;\n    pointer.moved = false;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.deltaX = 0;\n    pointer.deltaY = 0;\n    pointer.color = generateColor();\n}\nfunction updatePointerMoveData(pointer, posX, posY) {\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n    pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction updatePointerUpData(pointer) {\n    pointer.down = false;\n}\nfunction correctDeltaX(delta) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1) delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) delta /= aspectRatio;\n    return delta;\n}\nfunction generateColor() {\n    let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.15;\n    c.g *= 0.15;\n    c.b *= 0.15;\n    return c;\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b, i, f, p, q, t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v, g = t, b = p;\n            break;\n        case 1:\n            r = q, g = v, b = p;\n            break;\n        case 2:\n            r = p, g = v, b = t;\n            break;\n        case 3:\n            r = p, g = q, b = v;\n            break;\n        case 4:\n            r = t, g = p, b = v;\n            break;\n        case 5:\n            r = v, g = p, b = q;\n            break;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\n_c1 = HSVtoRGB;\nfunction normalizeColor(input) {\n    let output = {\n        r: input.r / 255,\n        g: input.g / 255,\n        b: input.b / 255\n    };\n    return output;\n}\nfunction wrap(value1, min, max) {\n    let range = max - min;\n    if (range == 0) return min;\n    return (value1 - min) % range + min;\n}\nfunction getResolution(resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n    let min = Math.round(resolution);\n    let max = Math.round(resolution * aspectRatio);\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n        width: max,\n        height: min\n    };\n    else return {\n        width: min,\n        height: max\n    };\n}\nfunction getTextureScale(texture, width, height) {\n    return {\n        x: width / texture.width,\n        y: height / texture.height\n    };\n}\nfunction scaleByPixelRatio(input) {\n    let pixelRatio = window.devicePixelRatio || 1;\n    return Math.floor(input * pixelRatio);\n}\nfunction hashCode(s) {\n    if (s.length == 0) return 0;\n    let hash = 0;\n    for(let i = 0; i < s.length; i++){\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\nvar _c, _c1;\n$RefreshReg$(_c, \"CHECK_FRAMEBUFFER_STATUS\");\n$RefreshReg$(_c1, \"HSVtoRGB\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdwTCxHQUFHcUwsbUJBQW1CO0lBQ2hFLElBQUk0SCxjQUFjLEdBQUdBLGNBQWMsTUFBTUE7SUFFekMsSUFBSTNOLE1BQU1ELEtBQUsrUixLQUFLLENBQUNEO0lBQ3JCLElBQUk1UixNQUFNRixLQUFLK1IsS0FBSyxDQUFDRCxhQUFhbEU7SUFFbEMsSUFBSWpULEdBQUdvTCxrQkFBa0IsR0FBR3BMLEdBQUdxTCxtQkFBbUIsRUFDaEQsT0FBTztRQUFFdkgsT0FBT3lCO1FBQUt4QixRQUFRdUI7SUFBSTtTQUM5QixPQUFPO1FBQUV4QixPQUFPd0I7UUFBS3ZCLFFBQVF3QjtJQUFJO0FBQ3hDO0FBRUEsU0FBUzhOLGdCQUFnQnBSLE9BQU8sRUFBRTZCLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQy9DLE9BQU87UUFDTHdQLEdBQUd6UCxRQUFRN0IsUUFBUTZCLEtBQUs7UUFDeEIwUCxHQUFHelAsU0FBUzlCLFFBQVE4QixNQUFNO0lBQzVCO0FBQ0Y7QUFFQSxTQUFTbU4sa0JBQWtCOUwsS0FBSyxFQUFFO0lBQ2hDLElBQUlpUyxhQUFhdGEsT0FBT3VhLGdCQUFnQixJQUFJO0lBQzVDLE9BQU9qUyxLQUFLMlIsS0FBSyxDQUFDNVIsUUFBUWlTO0FBQzVCO0FBRUEsU0FBU3pRLFNBQVMrUCxDQUFDLEVBQUU7SUFDbkIsSUFBSUEsRUFBRWpTLE1BQU0sSUFBSSxHQUFHLE9BQU87SUFDMUIsSUFBSWlDLE9BQU87SUFDWCxJQUFLLElBQUkzQixJQUFJLEdBQUdBLElBQUkyUixFQUFFalMsTUFBTSxFQUFFTSxJQUFLO1FBQ2pDMkIsT0FBTyxDQUFDQSxRQUFRLEtBQUtBLE9BQU9nUSxFQUFFWSxVQUFVLENBQUN2UztRQUN6QzJCLFFBQVEsR0FBRywyQkFBMkI7SUFDeEM7SUFDQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NoYXJlZC9saWIvd2ViZ2wuanM/M2QwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuTUlUIExpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBQYXZlbCBEb2JyeWFrb3ZcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTaW11bGF0aW9uIHNlY3Rpb25cbmxldCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbW9rZS13ZWJnbCcpWzBdO1xuY29uc29sZS5sb2coY2FudmFzKTtcbnJlc2l6ZUNhbnZhcygpO1xuXG5sZXQgY29uZmlnID0ge1xuICBTSU1fUkVTT0xVVElPTjogMTI4LFxuICBEWUVfUkVTT0xVVElPTjogMTAyNCxcbiAgQ0FQVFVSRV9SRVNPTFVUSU9OOiA1MTIsXG4gIERFTlNJVFlfRElTU0lQQVRJT046IDEsXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OOiAwLjIsXG4gIFBSRVNTVVJFOiAwLjgsXG4gIFBSRVNTVVJFX0lURVJBVElPTlM6IDIwLFxuICBDVVJMOiAzMCxcbiAgU1BMQVRfUkFESVVTOiAwLjI1LFxuICBTUExBVF9GT1JDRTogNjAwMCxcbiAgU0hBRElORzogdHJ1ZSxcbiAgQ09MT1JGVUw6IHRydWUsXG4gIENPTE9SX1VQREFURV9TUEVFRDogMTAsXG4gIFBBVVNFRDogZmFsc2UsXG4gIEJBQ0tfQ09MT1I6IHsgcjogMCwgZzogMCwgYjogMCB9LFxuICBUUkFOU1BBUkVOVDogZmFsc2UsXG4gIEJMT09NOiB0cnVlLFxuICBCTE9PTV9JVEVSQVRJT05TOiA4LFxuICBCTE9PTV9SRVNPTFVUSU9OOiAyNTYsXG4gIEJMT09NX0lOVEVOU0lUWTogMC44LFxuICBCTE9PTV9USFJFU0hPTEQ6IDAuNixcbiAgQkxPT01fU09GVF9LTkVFOiAwLjcsXG4gIFNVTlJBWVM6IHRydWUsXG4gIFNVTlJBWVNfUkVTT0xVVElPTjogMTk2LFxuICBTVU5SQVlTX1dFSUdIVDogMS4wLFxufTtcblxuZnVuY3Rpb24gcG9pbnRlclByb3RvdHlwZSgpIHtcbiAgdGhpcy5pZCA9IC0xO1xuICB0aGlzLnRleGNvb3JkWCA9IDA7XG4gIHRoaXMudGV4Y29vcmRZID0gMDtcbiAgdGhpcy5wcmV2VGV4Y29vcmRYID0gMDtcbiAgdGhpcy5wcmV2VGV4Y29vcmRZID0gMDtcbiAgdGhpcy5kZWx0YVggPSAwO1xuICB0aGlzLmRlbHRhWSA9IDA7XG4gIHRoaXMuZG93biA9IGZhbHNlO1xuICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gIHRoaXMuY29sb3IgPSBbMzAsIDAsIDMwMF07XG59XG5cbmxldCBwb2ludGVycyA9IFtdO1xubGV0IHNwbGF0U3RhY2sgPSBbXTtcbnBvaW50ZXJzLnB1c2gobmV3IHBvaW50ZXJQcm90b3R5cGUoKSk7XG5cbmNvbnN0IHsgZ2wsIGV4dCB9ID0gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcyk7XG5cbmlmIChpc01vYmlsZSgpKSB7XG4gIGNvbmZpZy5EWUVfUkVTT0xVVElPTiA9IDUxMjtcbn1cbmlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgY29uZmlnLkRZRV9SRVNPTFVUSU9OID0gNTEyO1xuICBjb25maWcuU0hBRElORyA9IGZhbHNlO1xuICBjb25maWcuQkxPT00gPSBmYWxzZTtcbiAgY29uZmlnLlNVTlJBWVMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhcykge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgYWxwaGE6IHRydWUsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgfTtcblxuICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgcGFyYW1zKTtcbiAgY29uc3QgaXNXZWJHTDIgPSAhIWdsO1xuICBpZiAoIWlzV2ViR0wyKVxuICAgIGdsID1cbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHBhcmFtcykgfHxcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBwYXJhbXMpO1xuXG4gIGxldCBoYWxmRmxvYXQ7XG4gIGxldCBzdXBwb3J0TGluZWFyRmlsdGVyaW5nO1xuICBpZiAoaXNXZWJHTDIpIHtcbiAgICBnbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKTtcbiAgfSBlbHNlIHtcbiAgICBoYWxmRmxvYXQgPSBnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnKTtcbiAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicpO1xuICB9XG5cbiAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuXG4gIGNvbnN0IGhhbGZGbG9hdFRleFR5cGUgPSBpc1dlYkdMMiA/IGdsLkhBTEZfRkxPQVQgOiBoYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVM7XG4gIGxldCBmb3JtYXRSR0JBO1xuICBsZXQgZm9ybWF0Ukc7XG4gIGxldCBmb3JtYXRSO1xuXG4gIGlmIChpc1dlYkdMMikge1xuICAgIGZvcm1hdFJHQkEgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkExNkYsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgIGZvcm1hdFJHID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SRzE2RiwgZ2wuUkcsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgIGZvcm1hdFIgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlIxNkYsIGdsLlJFRCwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9ybWF0UkdCQSA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQSwgZ2wuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgZm9ybWF0UkcgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgIGZvcm1hdFIgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnbCxcbiAgICBleHQ6IHtcbiAgICAgIGZvcm1hdFJHQkEsXG4gICAgICBmb3JtYXRSRyxcbiAgICAgIGZvcm1hdFIsXG4gICAgICBoYWxmRmxvYXRUZXhUeXBlLFxuICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyxcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUpIHtcbiAgaWYgKCFzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdChnbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSkpIHtcbiAgICBzd2l0Y2ggKGludGVybmFsRm9ybWF0KSB7XG4gICAgICBjYXNlIGdsLlIxNkY6XG4gICAgICAgIHJldHVybiBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHMTZGLCBnbC5SRywgdHlwZSk7XG4gICAgICBjYXNlIGdsLlJHMTZGOlxuICAgICAgICByZXR1cm4gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBMTZGLCBnbC5SR0JBLCB0eXBlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgZm9ybWF0LFxuICB9O1xufVxuXG5mdW5jdGlvbiBzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdChnbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSkge1xuICBsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDQsIDQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG5cbiAgbGV0IGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgZ2wuVEVYVFVSRV8yRCxcbiAgICB0ZXh0dXJlLFxuICAgIDBcbiAgKTtcblxuICBsZXQgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG4gIHJldHVybiBzdGF0dXMgPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU7XG59XG5cbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICByZXR1cm4gL01vYml8QW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVTY3JlZW5zaG90KCkge1xuICBsZXQgcmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuQ0FQVFVSRV9SRVNPTFVUSU9OKTtcbiAgbGV0IHRhcmdldCA9IGNyZWF0ZUZCTyhcbiAgICByZXMud2lkdGgsXG4gICAgcmVzLmhlaWdodCxcbiAgICBleHQuZm9ybWF0UkdCQS5pbnRlcm5hbEZvcm1hdCxcbiAgICBleHQuZm9ybWF0UkdCQS5mb3JtYXQsXG4gICAgZXh0LmhhbGZGbG9hdFRleFR5cGUsXG4gICAgZ2wuTkVBUkVTVFxuICApO1xuICByZW5kZXIodGFyZ2V0KTtcblxuICBsZXQgdGV4dHVyZSA9IGZyYW1lYnVmZmVyVG9UZXh0dXJlKHRhcmdldCk7XG4gIHRleHR1cmUgPSBub3JtYWxpemVUZXh0dXJlKHRleHR1cmUsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG5cbiAgbGV0IGNhcHR1cmVDYW52YXMgPSB0ZXh0dXJlVG9DYW52YXModGV4dHVyZSwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgbGV0IGRhdGF1cmkgPSBjYXB0dXJlQ2FudmFzLnRvRGF0YVVSTCgpO1xuICBkb3dubG9hZFVSSSgnZmx1aWQucG5nJywgZGF0YXVyaSk7XG4gIFVSTC5yZXZva2VPYmplY3RVUkwoZGF0YXVyaSk7XG59XG5cbmZ1bmN0aW9uIGZyYW1lYnVmZmVyVG9UZXh0dXJlKHRhcmdldCkge1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRhcmdldC5mYm8pO1xuICBsZXQgbGVuZ3RoID0gdGFyZ2V0LndpZHRoICogdGFyZ2V0LmhlaWdodCAqIDQ7XG4gIGxldCB0ZXh0dXJlID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRleHR1cmUpO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dHVyZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlLmxlbmd0aCk7XG4gIGxldCBpZCA9IDA7XG4gIGZvciAobGV0IGkgPSBoZWlnaHQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgbGV0IG5pZCA9IGkgKiB3aWR0aCAqIDQgKyBqICogNDtcbiAgICAgIHJlc3VsdFtuaWQgKyAwXSA9IGNsYW1wMDEodGV4dHVyZVtpZCArIDBdKSAqIDI1NTtcbiAgICAgIHJlc3VsdFtuaWQgKyAxXSA9IGNsYW1wMDEodGV4dHVyZVtpZCArIDFdKSAqIDI1NTtcbiAgICAgIHJlc3VsdFtuaWQgKyAyXSA9IGNsYW1wMDEodGV4dHVyZVtpZCArIDJdKSAqIDI1NTtcbiAgICAgIHJlc3VsdFtuaWQgKyAzXSA9IGNsYW1wMDEodGV4dHVyZVtpZCArIDNdKSAqIDI1NTtcbiAgICAgIGlkICs9IDQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNsYW1wMDEoaW5wdXQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGlucHV0LCAwKSwgMSk7XG59XG5cbmZ1bmN0aW9uIHRleHR1cmVUb0NhbnZhcyh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCBjYXB0dXJlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGxldCBjdHggPSBjYXB0dXJlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGNhcHR1cmVDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FwdHVyZUNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgbGV0IGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gIGltYWdlRGF0YS5kYXRhLnNldCh0ZXh0dXJlKTtcbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gIHJldHVybiBjYXB0dXJlQ2FudmFzO1xufVxuXG5mdW5jdGlvbiBkb3dubG9hZFVSSShmaWxlbmFtZSwgdXJpKSB7XG4gIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gIGxpbmsuaHJlZiA9IHVyaTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgbGluay5jbGljaygpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xufVxuXG5jbGFzcyBNYXRlcmlhbCB7XG4gIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG4gICAgdGhpcy5wcm9ncmFtcyA9IFtdO1xuICAgIHRoaXMuYWN0aXZlUHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy51bmlmb3JtcyA9IFtdO1xuICB9XG5cbiAgc2V0S2V5d29yZHMoa2V5d29yZHMpIHtcbiAgICBsZXQgaGFzaCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXl3b3Jkcy5sZW5ndGg7IGkrKykgaGFzaCArPSBoYXNoQ29kZShrZXl3b3Jkc1tpXSk7XG5cbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbaGFzaF07XG4gICAgaWYgKHByb2dyYW0gPT0gbnVsbCkge1xuICAgICAgbGV0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlLFxuICAgICAgICBrZXl3b3Jkc1xuICAgICAgKTtcbiAgICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKHRoaXMudmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICB0aGlzLnByb2dyYW1zW2hhc2hdID0gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBpZiAocHJvZ3JhbSA9PSB0aGlzLmFjdGl2ZVByb2dyYW0pIHJldHVybjtcblxuICAgIHRoaXMudW5pZm9ybXMgPSBnZXRVbmlmb3Jtcyhwcm9ncmFtKTtcbiAgICB0aGlzLmFjdGl2ZVByb2dyYW0gPSBwcm9ncmFtO1xuICB9XG5cbiAgYmluZCgpIHtcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMuYWN0aXZlUHJvZ3JhbSk7XG4gIH1cbn1cblxuY2xhc3MgUHJvZ3JhbSB7XG4gIGNvbnN0cnVjdG9yKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgdGhpcy5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gZ2V0VW5pZm9ybXModGhpcy5wcm9ncmFtKTtcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xuICBsZXQgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAgY29uc29sZS50cmFjZShnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG5cbiAgcmV0dXJuIHByb2dyYW07XG59XG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1zKHByb2dyYW0pIHtcbiAgbGV0IHVuaWZvcm1zID0gW107XG4gIGxldCB1bmlmb3JtQ291bnQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pZm9ybUNvdW50OyBpKyspIHtcbiAgICBsZXQgdW5pZm9ybU5hbWUgPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpLm5hbWU7XG4gICAgdW5pZm9ybXNbdW5pZm9ybU5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIodHlwZSwgc291cmNlLCBrZXl3b3Jkcykge1xuICBzb3VyY2UgPSBhZGRLZXl3b3Jkcyhzb3VyY2UsIGtleXdvcmRzKTtcblxuICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICBjb25zb2xlLnRyYWNlKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG5cbiAgcmV0dXJuIHNoYWRlcjtcbn1cblxuZnVuY3Rpb24gYWRkS2V5d29yZHMoc291cmNlLCBrZXl3b3Jkcykge1xuICBpZiAoa2V5d29yZHMgPT0gbnVsbCkgcmV0dXJuIHNvdXJjZTtcbiAgbGV0IGtleXdvcmRzU3RyaW5nID0gJyc7XG4gIGtleXdvcmRzLmZvckVhY2goKGtleXdvcmQpID0+IHtcbiAgICBrZXl3b3Jkc1N0cmluZyArPSAnI2RlZmluZSAnICsga2V5d29yZCArICdcXG4nO1xuICB9KTtcbiAgcmV0dXJuIGtleXdvcmRzU3RyaW5nICsgc291cmNlO1xufVxuXG5jb25zdCBiYXNlVmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuVkVSVEVYX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2VXYgPSBhUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgICAgIHZMID0gdlV2IC0gdmVjMih0ZXhlbFNpemUueCwgMC4wKTtcbiAgICAgICAgdlIgPSB2VXYgKyB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICB2VCA9IHZVdiArIHZlYzIoMC4wLCB0ZXhlbFNpemUueSk7XG4gICAgICAgIHZCID0gdlV2IC0gdmVjMigwLjAsIHRleGVsU2l6ZS55KTtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGJsdXJWZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5WRVJURVhfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2VXYgPSBhUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgICAgIGZsb2F0IG9mZnNldCA9IDEuMzMzMzMzMzM7XG4gICAgICAgIHZMID0gdlV2IC0gdGV4ZWxTaXplICogb2Zmc2V0O1xuICAgICAgICB2UiA9IHZVdiArIHRleGVsU2l6ZSAqIG9mZnNldDtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGJsdXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzQgc3VtID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpICogMC4yOTQxMTc2NDtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpICogMC4zNTI5NDExNztcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlIpICogMC4zNTI5NDExNztcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGNvcHlTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgfVxuYFxuKTtcblxuY29uc3QgY2xlYXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHZhbHVlO1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZhbHVlICogdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGNvbG9yU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGNoZWNrZXJib2FyZFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCBhc3BlY3RSYXRpbztcbiAgICAjZGVmaW5lIFNDQUxFIDI1LjBcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWMyIHV2ID0gZmxvb3IodlV2ICogU0NBTEUgKiB2ZWMyKGFzcGVjdFJhdGlvLCAxLjApKTtcbiAgICAgICAgZmxvYXQgdiA9IG1vZCh1di54ICsgdXYueSwgMi4wKTtcbiAgICAgICAgdiA9IHYgKiAwLjEgKyAwLjg7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyh2KSwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBkaXNwbGF5U2hhZGVyU291cmNlID0gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVCbG9vbTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U3VucmF5cztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl0aGVyaW5nO1xuICAgIHVuaWZvcm0gdmVjMiBkaXRoZXJTY2FsZTtcbiAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuICAgIHZlYzMgbGluZWFyVG9HYW1tYSAodmVjMyBjb2xvcikge1xuICAgICAgICBjb2xvciA9IG1heChjb2xvciwgdmVjMygwKSk7XG4gICAgICAgIHJldHVybiBtYXgoMS4wNTUgKiBwb3coY29sb3IsIHZlYzMoMC40MTY2NjY2NjcpKSAtIDAuMDU1LCB2ZWMzKDApKTtcbiAgICB9XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMyBjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLnJnYjtcbiAgICAjaWZkZWYgU0hBRElOR1xuICAgICAgICB2ZWMzIGxjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCkucmdiO1xuICAgICAgICB2ZWMzIHJjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2UikucmdiO1xuICAgICAgICB2ZWMzIHRjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VCkucmdiO1xuICAgICAgICB2ZWMzIGJjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2QikucmdiO1xuICAgICAgICBmbG9hdCBkeCA9IGxlbmd0aChyYykgLSBsZW5ndGgobGMpO1xuICAgICAgICBmbG9hdCBkeSA9IGxlbmd0aCh0YykgLSBsZW5ndGgoYmMpO1xuICAgICAgICB2ZWMzIG4gPSBub3JtYWxpemUodmVjMyhkeCwgZHksIGxlbmd0aCh0ZXhlbFNpemUpKSk7XG4gICAgICAgIHZlYzMgbCA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIGZsb2F0IGRpZmZ1c2UgPSBjbGFtcChkb3QobiwgbCkgKyAwLjcsIDAuNywgMS4wKTtcbiAgICAgICAgYyAqPSBkaWZmdXNlO1xuICAgICNlbmRpZlxuICAgICNpZmRlZiBCTE9PTVxuICAgICAgICB2ZWMzIGJsb29tID0gdGV4dHVyZTJEKHVCbG9vbSwgdlV2KS5yZ2I7XG4gICAgI2VuZGlmXG4gICAgI2lmZGVmIFNVTlJBWVNcbiAgICAgICAgZmxvYXQgc3VucmF5cyA9IHRleHR1cmUyRCh1U3VucmF5cywgdlV2KS5yO1xuICAgICAgICBjICo9IHN1bnJheXM7XG4gICAgI2lmZGVmIEJMT09NXG4gICAgICAgIGJsb29tICo9IHN1bnJheXM7XG4gICAgI2VuZGlmXG4gICAgI2VuZGlmXG4gICAgI2lmZGVmIEJMT09NXG4gICAgICAgIGZsb2F0IG5vaXNlID0gdGV4dHVyZTJEKHVEaXRoZXJpbmcsIHZVdiAqIGRpdGhlclNjYWxlKS5yO1xuICAgICAgICBub2lzZSA9IG5vaXNlICogMi4wIC0gMS4wO1xuICAgICAgICBibG9vbSArPSBub2lzZSAvIDI1NS4wO1xuICAgICAgICBibG9vbSA9IGxpbmVhclRvR2FtbWEoYmxvb20pO1xuICAgICAgICBjICs9IGJsb29tO1xuICAgICNlbmRpZlxuICAgICAgICBmbG9hdCBhID0gbWF4KGMuciwgbWF4KGMuZywgYy5iKSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYywgYSk7XG4gICAgfVxuYDtcblxuY29uc3QgYmxvb21QcmVmaWx0ZXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIHZlYzMgY3VydmU7XG4gICAgdW5pZm9ybSBmbG9hdCB0aHJlc2hvbGQ7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMyBjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLnJnYjtcbiAgICAgICAgZmxvYXQgYnIgPSBtYXgoYy5yLCBtYXgoYy5nLCBjLmIpKTtcbiAgICAgICAgZmxvYXQgcnEgPSBjbGFtcChiciAtIGN1cnZlLngsIDAuMCwgY3VydmUueSk7XG4gICAgICAgIHJxID0gY3VydmUueiAqIHJxICogcnE7XG4gICAgICAgIGMgKj0gbWF4KHJxLCBiciAtIHRocmVzaG9sZCkgLyBtYXgoYnIsIDAuMDAwMSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYywgMC4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBibG9vbUJsdXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLjApO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCk7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Qik7XG4gICAgICAgIHN1bSAqPSAwLjI1O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBzdW07XG4gICAgfVxuYFxuKTtcblxuY29uc3QgYmxvb21GaW5hbFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZMKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlIpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VCk7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZCKTtcbiAgICAgICAgc3VtICo9IDAuMjU7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHN1bSAqIGludGVuc2l0eTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBzdW5yYXlzTWFza1NoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjNCBjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgICAgICBmbG9hdCBiciA9IG1heChjLnIsIG1heChjLmcsIGMuYikpO1xuICAgICAgICBjLmEgPSAxLjAgLSBtaW4obWF4KGJyICogMjAuMCwgMC4wKSwgMC44KTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYztcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBzdW5yYXlzU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHdlaWdodDtcbiAgICAjZGVmaW5lIElURVJBVElPTlMgMTZcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBEZW5zaXR5ID0gMC4zO1xuICAgICAgICBmbG9hdCBEZWNheSA9IDAuOTU7XG4gICAgICAgIGZsb2F0IEV4cG9zdXJlID0gMC43O1xuICAgICAgICB2ZWMyIGNvb3JkID0gdlV2O1xuICAgICAgICB2ZWMyIGRpciA9IHZVdiAtIDAuNTtcbiAgICAgICAgZGlyICo9IDEuMCAvIGZsb2F0KElURVJBVElPTlMpICogRGVuc2l0eTtcbiAgICAgICAgZmxvYXQgaWxsdW1pbmF0aW9uRGVjYXkgPSAxLjA7XG4gICAgICAgIGZsb2F0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLmE7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgSVRFUkFUSU9OUzsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb29yZCAtPSBkaXI7XG4gICAgICAgICAgICBmbG9hdCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIGNvb3JkKS5hO1xuICAgICAgICAgICAgY29sb3IgKz0gY29sICogaWxsdW1pbmF0aW9uRGVjYXkgKiB3ZWlnaHQ7XG4gICAgICAgICAgICBpbGx1bWluYXRpb25EZWNheSAqPSBEZWNheTtcbiAgICAgICAgfVxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yICogRXhwb3N1cmUsIDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IHNwbGF0U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGFyZ2V0O1xuICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwb2ludDtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWMyIHAgPSB2VXYgLSBwb2ludC54eTtcbiAgICAgICAgcC54ICo9IGFzcGVjdFJhdGlvO1xuICAgICAgICB2ZWMzIHNwbGF0ID0gZXhwKC1kb3QocCwgcCkgLyByYWRpdXMpICogY29sb3I7XG4gICAgICAgIHZlYzMgYmFzZSA9IHRleHR1cmUyRCh1VGFyZ2V0LCB2VXYpLnh5ejtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChiYXNlICsgc3BsYXQsIDEuMCk7XG4gICAgfVxuYFxuKTtcblxuY29uc3QgYWR2ZWN0aW9uU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNvdXJjZTtcbiAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuICAgIHVuaWZvcm0gdmVjMiBkeWVUZXhlbFNpemU7XG4gICAgdW5pZm9ybSBmbG9hdCBkdDtcbiAgICB1bmlmb3JtIGZsb2F0IGRpc3NpcGF0aW9uO1xuICAgIHZlYzQgYmlsZXJwIChzYW1wbGVyMkQgc2FtLCB2ZWMyIHV2LCB2ZWMyIHRzaXplKSB7XG4gICAgICAgIHZlYzIgc3QgPSB1diAvIHRzaXplIC0gMC41O1xuICAgICAgICB2ZWMyIGl1diA9IGZsb29yKHN0KTtcbiAgICAgICAgdmVjMiBmdXYgPSBmcmFjdChzdCk7XG4gICAgICAgIHZlYzQgYSA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMC41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHZlYzQgYiA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDEuNSwgMC41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMS41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHZlYzQgZCA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDEuNSwgMS41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHJldHVybiBtaXgobWl4KGEsIGIsIGZ1di54KSwgbWl4KGMsIGQsIGZ1di54KSwgZnV2LnkpO1xuICAgIH1cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICNpZmRlZiBNQU5VQUxfRklMVEVSSU5HXG4gICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIGJpbGVycCh1VmVsb2NpdHksIHZVdiwgdGV4ZWxTaXplKS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSBiaWxlcnAodVNvdXJjZSwgY29vcmQsIGR5ZVRleGVsU2l6ZSk7XG4gICAgI2Vsc2VcbiAgICAgICAgdmVjMiBjb29yZCA9IHZVdiAtIGR0ICogdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSB0ZXh0dXJlMkQodVNvdXJjZSwgY29vcmQpO1xuICAgICNlbmRpZlxuICAgICAgICBmbG9hdCBkZWNheSA9IDEuMCArIGRpc3NpcGF0aW9uICogZHQ7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdCAvIGRlY2F5O1xuICAgIH1gLFxuICBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IG51bGwgOiBbJ01BTlVBTF9GSUxURVJJTkcnXVxuKTtcblxuY29uc3QgZGl2ZXJnZW5jZVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS54O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlIpLng7XG4gICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueTtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS55O1xuICAgICAgICB2ZWMyIEMgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICBpZiAodkwueCA8IDAuMCkgeyBMID0gLUMueDsgfVxuICAgICAgICBpZiAodlIueCA+IDEuMCkgeyBSID0gLUMueDsgfVxuICAgICAgICBpZiAodlQueSA+IDEuMCkgeyBUID0gLUMueTsgfVxuICAgICAgICBpZiAodkIueSA8IDAuMCkgeyBCID0gLUMueTsgfVxuICAgICAgICBmbG9hdCBkaXYgPSAwLjUgKiAoUiAtIEwgKyBUIC0gQik7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGl2LCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBjdXJsU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkwpLnk7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueTtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZUKS54O1xuICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkIpLng7XG4gICAgICAgIGZsb2F0IHZvcnRpY2l0eSA9IFIgLSBMIC0gVCArIEI7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC41ICogdm9ydGljaXR5LCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCB2b3J0aWNpdHlTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdUN1cmw7XG4gICAgdW5pZm9ybSBmbG9hdCBjdXJsO1xuICAgIHVuaWZvcm0gZmxvYXQgZHQ7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1Q3VybCwgdkwpLng7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodUN1cmwsIHZSKS54O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVDdXJsLCB2VCkueDtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1Q3VybCwgdkIpLng7XG4gICAgICAgIGZsb2F0IEMgPSB0ZXh0dXJlMkQodUN1cmwsIHZVdikueDtcbiAgICAgICAgdmVjMiBmb3JjZSA9IDAuNSAqIHZlYzIoYWJzKFQpIC0gYWJzKEIpLCBhYnMoUikgLSBhYnMoTCkpO1xuICAgICAgICBmb3JjZSAvPSBsZW5ndGgoZm9yY2UpICsgMC4wMDAxO1xuICAgICAgICBmb3JjZSAqPSBjdXJsICogQztcbiAgICAgICAgZm9yY2UueSAqPSAtMS4wO1xuICAgICAgICB2ZWMyIHZlbG9jaXR5ID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgdmVsb2NpdHkgKz0gZm9yY2UgKiBkdDtcbiAgICAgICAgdmVsb2NpdHkgPSBtaW4obWF4KHZlbG9jaXR5LCAtMTAwMC4wKSwgMTAwMC4wKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWxvY2l0eSwgMC4wLCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IHByZXNzdXJlU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVQcmVzc3VyZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl2ZXJnZW5jZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2UikueDtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgIGZsb2F0IEMgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2VXYpLng7XG4gICAgICAgIGZsb2F0IGRpdmVyZ2VuY2UgPSB0ZXh0dXJlMkQodURpdmVyZ2VuY2UsIHZVdikueDtcbiAgICAgICAgZmxvYXQgcHJlc3N1cmUgPSAoTCArIFIgKyBCICsgVCAtIGRpdmVyZ2VuY2UpICogMC4yNTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChwcmVzc3VyZSwgMC4wLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuKTtcblxuY29uc3QgZ3JhZGllbnRTdWJ0cmFjdFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1UHJlc3N1cmU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2TCkueDtcbiAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlQpLng7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2QikueDtcbiAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgIHZlbG9jaXR5Lnh5IC09IHZlYzIoUiAtIEwsIFQgLSBCKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWxvY2l0eSwgMC4wLCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGJsaXQgPSAoKCkgPT4ge1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpO1xuICBnbC5idWZmZXJEYXRhKFxuICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIC0xLCAxLCAxLCAxLCAxLCAtMV0pLFxuICAgIGdsLlNUQVRJQ19EUkFXXG4gICk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgZ2wuYnVmZmVyRGF0YShcbiAgICBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixcbiAgICBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKSxcbiAgICBnbC5TVEFUSUNfRFJBV1xuICApO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKDAsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDApO1xuXG4gIHJldHVybiAodGFyZ2V0LCBjbGVhciA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGFyZ2V0LmZibyk7XG4gICAgfVxuICAgIGlmIChjbGVhcikge1xuICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgfVxuICAgIC8vIENIRUNLX0ZSQU1FQlVGRkVSX1NUQVRVUygpO1xuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIENIRUNLX0ZSQU1FQlVGRkVSX1NUQVRVUygpIHtcbiAgbGV0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICBpZiAoc3RhdHVzICE9IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKVxuICAgIGNvbnNvbGUudHJhY2UoJ0ZyYW1lYnVmZmVyIGVycm9yOiAnICsgc3RhdHVzKTtcbn1cblxubGV0IGR5ZTtcbmxldCB2ZWxvY2l0eTtcbmxldCBkaXZlcmdlbmNlO1xubGV0IGN1cmw7XG5sZXQgcHJlc3N1cmU7XG5sZXQgYmxvb207XG5sZXQgYmxvb21GcmFtZWJ1ZmZlcnMgPSBbXTtcbmxldCBzdW5yYXlzO1xubGV0IHN1bnJheXNUZW1wO1xuXG5sZXQgZGl0aGVyaW5nVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmVBc3luYygnTERSX0xMTDFfMC5wbmcnKTtcblxuY29uc3QgYmx1clByb2dyYW0gPSBuZXcgUHJvZ3JhbShibHVyVmVydGV4U2hhZGVyLCBibHVyU2hhZGVyKTtcbmNvbnN0IGNvcHlQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY29weVNoYWRlcik7XG5jb25zdCBjbGVhclByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjbGVhclNoYWRlcik7XG5jb25zdCBjb2xvclByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjb2xvclNoYWRlcik7XG5jb25zdCBjaGVja2VyYm9hcmRQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY2hlY2tlcmJvYXJkU2hhZGVyKTtcbmNvbnN0IGJsb29tUHJlZmlsdGVyUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKFxuICBiYXNlVmVydGV4U2hhZGVyLFxuICBibG9vbVByZWZpbHRlclNoYWRlclxuKTtcbmNvbnN0IGJsb29tQmx1clByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBibG9vbUJsdXJTaGFkZXIpO1xuY29uc3QgYmxvb21GaW5hbFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBibG9vbUZpbmFsU2hhZGVyKTtcbmNvbnN0IHN1bnJheXNNYXNrUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHN1bnJheXNNYXNrU2hhZGVyKTtcbmNvbnN0IHN1bnJheXNQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgc3VucmF5c1NoYWRlcik7XG5jb25zdCBzcGxhdFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBzcGxhdFNoYWRlcik7XG5jb25zdCBhZHZlY3Rpb25Qcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYWR2ZWN0aW9uU2hhZGVyKTtcbmNvbnN0IGRpdmVyZ2VuY2VQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgZGl2ZXJnZW5jZVNoYWRlcik7XG5jb25zdCBjdXJsUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGN1cmxTaGFkZXIpO1xuY29uc3Qgdm9ydGljaXR5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHZvcnRpY2l0eVNoYWRlcik7XG5jb25zdCBwcmVzc3VyZVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBwcmVzc3VyZVNoYWRlcik7XG5jb25zdCBncmFkaWVuU3VidHJhY3RQcm9ncmFtID0gbmV3IFByb2dyYW0oXG4gIGJhc2VWZXJ0ZXhTaGFkZXIsXG4gIGdyYWRpZW50U3VidHJhY3RTaGFkZXJcbik7XG5cbmNvbnN0IGRpc3BsYXlNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChiYXNlVmVydGV4U2hhZGVyLCBkaXNwbGF5U2hhZGVyU291cmNlKTtcblxuZnVuY3Rpb24gaW5pdEZyYW1lYnVmZmVycygpIHtcbiAgbGV0IHNpbVJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLlNJTV9SRVNPTFVUSU9OKTtcbiAgbGV0IGR5ZVJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLkRZRV9SRVNPTFVUSU9OKTtcblxuICBjb25zdCB0ZXhUeXBlID0gZXh0LmhhbGZGbG9hdFRleFR5cGU7XG4gIGNvbnN0IHJnYmEgPSBleHQuZm9ybWF0UkdCQTtcbiAgY29uc3QgcmcgPSBleHQuZm9ybWF0Ukc7XG4gIGNvbnN0IHIgPSBleHQuZm9ybWF0UjtcbiAgY29uc3QgZmlsdGVyaW5nID0gZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUO1xuXG4gIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gIGlmIChkeWUgPT0gbnVsbClcbiAgICBkeWUgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICBkeWVSZXMud2lkdGgsXG4gICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHJnYmEuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgICk7XG4gIGVsc2VcbiAgICBkeWUgPSByZXNpemVEb3VibGVGQk8oXG4gICAgICBkeWUsXG4gICAgICBkeWVSZXMud2lkdGgsXG4gICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHJnYmEuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgICk7XG5cbiAgaWYgKHZlbG9jaXR5ID09IG51bGwpXG4gICAgdmVsb2NpdHkgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICBzaW1SZXMud2lkdGgsXG4gICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgcmcuaW50ZXJuYWxGb3JtYXQsXG4gICAgICByZy5mb3JtYXQsXG4gICAgICB0ZXhUeXBlLFxuICAgICAgZmlsdGVyaW5nXG4gICAgKTtcbiAgZWxzZVxuICAgIHZlbG9jaXR5ID0gcmVzaXplRG91YmxlRkJPKFxuICAgICAgdmVsb2NpdHksXG4gICAgICBzaW1SZXMud2lkdGgsXG4gICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgcmcuaW50ZXJuYWxGb3JtYXQsXG4gICAgICByZy5mb3JtYXQsXG4gICAgICB0ZXhUeXBlLFxuICAgICAgZmlsdGVyaW5nXG4gICAgKTtcblxuICBkaXZlcmdlbmNlID0gY3JlYXRlRkJPKFxuICAgIHNpbVJlcy53aWR0aCxcbiAgICBzaW1SZXMuaGVpZ2h0LFxuICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgci5mb3JtYXQsXG4gICAgdGV4VHlwZSxcbiAgICBnbC5ORUFSRVNUXG4gICk7XG4gIGN1cmwgPSBjcmVhdGVGQk8oXG4gICAgc2ltUmVzLndpZHRoLFxuICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICByLmZvcm1hdCxcbiAgICB0ZXhUeXBlLFxuICAgIGdsLk5FQVJFU1RcbiAgKTtcbiAgcHJlc3N1cmUgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgc2ltUmVzLndpZHRoLFxuICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICByLmZvcm1hdCxcbiAgICB0ZXhUeXBlLFxuICAgIGdsLk5FQVJFU1RcbiAgKTtcblxuICBpbml0Qmxvb21GcmFtZWJ1ZmZlcnMoKTtcbiAgaW5pdFN1bnJheXNGcmFtZWJ1ZmZlcnMoKTtcbn1cblxuZnVuY3Rpb24gaW5pdEJsb29tRnJhbWVidWZmZXJzKCkge1xuICBsZXQgcmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuQkxPT01fUkVTT0xVVElPTik7XG5cbiAgY29uc3QgdGV4VHlwZSA9IGV4dC5oYWxmRmxvYXRUZXhUeXBlO1xuICBjb25zdCByZ2JhID0gZXh0LmZvcm1hdFJHQkE7XG4gIGNvbnN0IGZpbHRlcmluZyA9IGV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcblxuICBibG9vbSA9IGNyZWF0ZUZCTyhcbiAgICByZXMud2lkdGgsXG4gICAgcmVzLmhlaWdodCxcbiAgICByZ2JhLmludGVybmFsRm9ybWF0LFxuICAgIHJnYmEuZm9ybWF0LFxuICAgIHRleFR5cGUsXG4gICAgZmlsdGVyaW5nXG4gICk7XG5cbiAgYmxvb21GcmFtZWJ1ZmZlcnMubGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcuQkxPT01fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgbGV0IHdpZHRoID0gcmVzLndpZHRoID4+IChpICsgMSk7XG4gICAgbGV0IGhlaWdodCA9IHJlcy5oZWlnaHQgPj4gKGkgKyAxKTtcblxuICAgIGlmICh3aWR0aCA8IDIgfHwgaGVpZ2h0IDwgMikgYnJlYWs7XG5cbiAgICBsZXQgZmJvID0gY3JlYXRlRkJPKFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByZ2JhLmludGVybmFsRm9ybWF0LFxuICAgICAgcmdiYS5mb3JtYXQsXG4gICAgICB0ZXhUeXBlLFxuICAgICAgZmlsdGVyaW5nXG4gICAgKTtcbiAgICBibG9vbUZyYW1lYnVmZmVycy5wdXNoKGZibyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFN1bnJheXNGcmFtZWJ1ZmZlcnMoKSB7XG4gIGxldCByZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5TVU5SQVlTX1JFU09MVVRJT04pO1xuXG4gIGNvbnN0IHRleFR5cGUgPSBleHQuaGFsZkZsb2F0VGV4VHlwZTtcbiAgY29uc3QgciA9IGV4dC5mb3JtYXRSO1xuICBjb25zdCBmaWx0ZXJpbmcgPSBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG5cbiAgc3VucmF5cyA9IGNyZWF0ZUZCTyhcbiAgICByZXMud2lkdGgsXG4gICAgcmVzLmhlaWdodCxcbiAgICByLmludGVybmFsRm9ybWF0LFxuICAgIHIuZm9ybWF0LFxuICAgIHRleFR5cGUsXG4gICAgZmlsdGVyaW5nXG4gICk7XG4gIHN1bnJheXNUZW1wID0gY3JlYXRlRkJPKFxuICAgIHJlcy53aWR0aCxcbiAgICByZXMuaGVpZ2h0LFxuICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgci5mb3JtYXQsXG4gICAgdGV4VHlwZSxcbiAgICBmaWx0ZXJpbmdcbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgdywgaCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcblxuICBsZXQgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pO1xuICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICBnbC5GUkFNRUJVRkZFUixcbiAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICBnbC5URVhUVVJFXzJELFxuICAgIHRleHR1cmUsXG4gICAgMFxuICApO1xuICBnbC52aWV3cG9ydCgwLCAwLCB3LCBoKTtcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgbGV0IHRleGVsU2l6ZVggPSAxLjAgLyB3O1xuICBsZXQgdGV4ZWxTaXplWSA9IDEuMCAvIGg7XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0dXJlLFxuICAgIGZibyxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdGV4ZWxTaXplWCxcbiAgICB0ZXhlbFNpemVZLFxuICAgIGF0dGFjaChpZCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURvdWJsZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICBsZXQgZmJvMSA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gIGxldCBmYm8yID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICB0ZXhlbFNpemVYOiBmYm8xLnRleGVsU2l6ZVgsXG4gICAgdGV4ZWxTaXplWTogZmJvMS50ZXhlbFNpemVZLFxuICAgIGdldCByZWFkKCkge1xuICAgICAgcmV0dXJuIGZibzE7XG4gICAgfSxcbiAgICBzZXQgcmVhZCh2YWx1ZSkge1xuICAgICAgZmJvMSA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHdyaXRlKCkge1xuICAgICAgcmV0dXJuIGZibzI7XG4gICAgfSxcbiAgICBzZXQgd3JpdGUodmFsdWUpIHtcbiAgICAgIGZibzIgPSB2YWx1ZTtcbiAgICB9LFxuICAgIHN3YXAoKSB7XG4gICAgICBsZXQgdGVtcCA9IGZibzE7XG4gICAgICBmYm8xID0gZmJvMjtcbiAgICAgIGZibzIgPSB0ZW1wO1xuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUZCTyh0YXJnZXQsIHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKSB7XG4gIGxldCBuZXdGQk8gPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICBjb3B5UHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0xaShjb3B5UHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgdGFyZ2V0LmF0dGFjaCgwKSk7XG4gIGJsaXQobmV3RkJPKTtcbiAgcmV0dXJuIG5ld0ZCTztcbn1cblxuZnVuY3Rpb24gcmVzaXplRG91YmxlRkJPKHRhcmdldCwgdywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pIHtcbiAgaWYgKHRhcmdldC53aWR0aCA9PSB3ICYmIHRhcmdldC5oZWlnaHQgPT0gaCkgcmV0dXJuIHRhcmdldDtcbiAgdGFyZ2V0LnJlYWQgPSByZXNpemVGQk8oXG4gICAgdGFyZ2V0LnJlYWQsXG4gICAgdyxcbiAgICBoLFxuICAgIGludGVybmFsRm9ybWF0LFxuICAgIGZvcm1hdCxcbiAgICB0eXBlLFxuICAgIHBhcmFtXG4gICk7XG4gIHRhcmdldC53cml0ZSA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gIHRhcmdldC53aWR0aCA9IHc7XG4gIHRhcmdldC5oZWlnaHQgPSBoO1xuICB0YXJnZXQudGV4ZWxTaXplWCA9IDEuMCAvIHc7XG4gIHRhcmdldC50ZXhlbFNpemVZID0gMS4wIC8gaDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUFzeW5jKHVybCkge1xuICBsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbiAgZ2wudGV4SW1hZ2UyRChcbiAgICBnbC5URVhUVVJFXzJELFxuICAgIDAsXG4gICAgZ2wuUkdCLFxuICAgIDEsXG4gICAgMSxcbiAgICAwLFxuICAgIGdsLlJHQixcbiAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgIG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1XSlcbiAgKTtcblxuICBsZXQgb2JqID0ge1xuICAgIHRleHR1cmUsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIGF0dGFjaChpZCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gIH07XG5cbiAgbGV0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICBvYmoud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBvYmouaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcbiAgfTtcbiAgaW1hZ2Uuc3JjID0gdXJsO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUtleXdvcmRzKCkge1xuICBsZXQgZGlzcGxheUtleXdvcmRzID0gW107XG4gIGlmIChjb25maWcuU0hBRElORykgZGlzcGxheUtleXdvcmRzLnB1c2goJ1NIQURJTkcnKTtcbiAgaWYgKGNvbmZpZy5CTE9PTSkgZGlzcGxheUtleXdvcmRzLnB1c2goJ0JMT09NJyk7XG4gIGlmIChjb25maWcuU1VOUkFZUykgZGlzcGxheUtleXdvcmRzLnB1c2goJ1NVTlJBWVMnKTtcbiAgZGlzcGxheU1hdGVyaWFsLnNldEtleXdvcmRzKGRpc3BsYXlLZXl3b3Jkcyk7XG59XG5cbnVwZGF0ZUtleXdvcmRzKCk7XG5pbml0RnJhbWVidWZmZXJzKCk7XG5tdWx0aXBsZVNwbGF0cyhwYXJzZUludChNYXRoLnJhbmRvbSgpICogMjApICsgNSk7XG5cbmxldCBsYXN0VXBkYXRlVGltZSA9IERhdGUubm93KCk7XG5sZXQgY29sb3JVcGRhdGVUaW1lciA9IDAuMDtcbnVwZGF0ZSgpO1xuXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIGNvbnN0IGR0ID0gY2FsY0RlbHRhVGltZSgpO1xuICBpZiAocmVzaXplQ2FudmFzKCkpIGluaXRGcmFtZWJ1ZmZlcnMoKTtcbiAgdXBkYXRlQ29sb3JzKGR0KTtcbiAgYXBwbHlJbnB1dHMoKTtcbiAgaWYgKCFjb25maWcuUEFVU0VEKSBzdGVwKGR0KTtcbiAgcmVuZGVyKG51bGwpO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcbn1cblxuZnVuY3Rpb24gY2FsY0RlbHRhVGltZSgpIHtcbiAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gIGxldCBkdCA9IChub3cgLSBsYXN0VXBkYXRlVGltZSkgLyAxMDAwO1xuICBkdCA9IE1hdGgubWluKGR0LCAwLjAxNjY2Nik7XG4gIGxhc3RVcGRhdGVUaW1lID0gbm93O1xuICByZXR1cm4gZHQ7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgbGV0IHdpZHRoID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgbGV0IGhlaWdodCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbG9ycyhkdCkge1xuICBpZiAoIWNvbmZpZy5DT0xPUkZVTCkgcmV0dXJuO1xuXG4gIGNvbG9yVXBkYXRlVGltZXIgKz0gZHQgKiBjb25maWcuQ09MT1JfVVBEQVRFX1NQRUVEO1xuICBpZiAoY29sb3JVcGRhdGVUaW1lciA+PSAxKSB7XG4gICAgY29sb3JVcGRhdGVUaW1lciA9IHdyYXAoY29sb3JVcGRhdGVUaW1lciwgMCwgMSk7XG4gICAgcG9pbnRlcnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgcC5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUlucHV0cygpIHtcbiAgaWYgKHNwbGF0U3RhY2subGVuZ3RoID4gMCkgbXVsdGlwbGVTcGxhdHMoc3BsYXRTdGFjay5wb3AoKSk7XG5cbiAgcG9pbnRlcnMuZm9yRWFjaCgocCkgPT4ge1xuICAgIGlmIChwLm1vdmVkKSB7XG4gICAgICBwLm1vdmVkID0gZmFsc2U7XG4gICAgICBzcGxhdFBvaW50ZXIocCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RlcChkdCkge1xuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICBjdXJsUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0yZihcbiAgICBjdXJsUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICk7XG4gIGdsLnVuaWZvcm0xaShjdXJsUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgYmxpdChjdXJsKTtcblxuICB2b3J0aWNpdHlQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTJmKFxuICAgIHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICApO1xuICBnbC51bmlmb3JtMWkodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgZ2wudW5pZm9ybTFpKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudUN1cmwsIGN1cmwuYXR0YWNoKDEpKTtcbiAgZ2wudW5pZm9ybTFmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuY3VybCwgY29uZmlnLkNVUkwpO1xuICBnbC51bmlmb3JtMWYodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpO1xuICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gIGRpdmVyZ2VuY2VQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTJmKFxuICAgIGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgKTtcbiAgZ2wudW5pZm9ybTFpKGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpO1xuICBibGl0KGRpdmVyZ2VuY2UpO1xuXG4gIGNsZWFyUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0xaShjbGVhclByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHByZXNzdXJlLnJlYWQuYXR0YWNoKDApKTtcbiAgZ2wudW5pZm9ybTFmKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy52YWx1ZSwgY29uZmlnLlBSRVNTVVJFKTtcbiAgYmxpdChwcmVzc3VyZS53cml0ZSk7XG4gIHByZXNzdXJlLnN3YXAoKTtcblxuICBwcmVzc3VyZVByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMmYoXG4gICAgcHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgKTtcbiAgZ2wudW5pZm9ybTFpKHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51RGl2ZXJnZW5jZSwgZGl2ZXJnZW5jZS5hdHRhY2goMCkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5QUkVTU1VSRV9JVEVSQVRJT05TOyBpKyspIHtcbiAgICBnbC51bmlmb3JtMWkocHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSwgcHJlc3N1cmUucmVhZC5hdHRhY2goMSkpO1xuICAgIGJsaXQocHJlc3N1cmUud3JpdGUpO1xuICAgIHByZXNzdXJlLnN3YXAoKTtcbiAgfVxuXG4gIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMmYoXG4gICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICk7XG4gIGdsLnVuaWZvcm0xaShcbiAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSxcbiAgICBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKVxuICApO1xuICBnbC51bmlmb3JtMWkoXG4gICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMSlcbiAgKTtcbiAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gIHZlbG9jaXR5LnN3YXAoKTtcblxuICBhZHZlY3Rpb25Qcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTJmKFxuICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICApO1xuICBpZiAoIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nKVxuICAgIGdsLnVuaWZvcm0yZihcbiAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHllVGV4ZWxTaXplLFxuICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICApO1xuICBsZXQgdmVsb2NpdHlJZCA9IHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApO1xuICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5SWQpO1xuICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51U291cmNlLCB2ZWxvY2l0eUlkKTtcbiAgZ2wudW5pZm9ybTFmKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZHQsIGR0KTtcbiAgZ2wudW5pZm9ybTFmKFxuICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZGlzc2lwYXRpb24sXG4gICAgY29uZmlnLlZFTE9DSVRZX0RJU1NJUEFUSU9OXG4gICk7XG4gIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgaWYgKCFleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZylcbiAgICBnbC51bmlmb3JtMmYoXG4gICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmR5ZVRleGVsU2l6ZSxcbiAgICAgIGR5ZS50ZXhlbFNpemVYLFxuICAgICAgZHllLnRleGVsU2l6ZVlcbiAgICApO1xuICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgZHllLnJlYWQuYXR0YWNoKDEpKTtcbiAgZ2wudW5pZm9ybTFmKFxuICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZGlzc2lwYXRpb24sXG4gICAgY29uZmlnLkRFTlNJVFlfRElTU0lQQVRJT05cbiAgKTtcbiAgYmxpdChkeWUud3JpdGUpO1xuICBkeWUuc3dhcCgpO1xufVxuXG5mdW5jdGlvbiByZW5kZXIodGFyZ2V0KSB7XG4gIGlmIChjb25maWcuQkxPT00pIGFwcGx5Qmxvb20oZHllLnJlYWQsIGJsb29tKTtcbiAgaWYgKGNvbmZpZy5TVU5SQVlTKSB7XG4gICAgYXBwbHlTdW5yYXlzKGR5ZS5yZWFkLCBkeWUud3JpdGUsIHN1bnJheXMpO1xuICAgIGJsdXIoc3VucmF5cywgc3VucmF5c1RlbXAsIDEpO1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PSBudWxsIHx8ICFjb25maWcuVFJBTlNQQVJFTlQpIHtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICB9IGVsc2Uge1xuICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICB9XG5cbiAgaWYgKCFjb25maWcuVFJBTlNQQVJFTlQpIGRyYXdDb2xvcih0YXJnZXQsIG5vcm1hbGl6ZUNvbG9yKGNvbmZpZy5CQUNLX0NPTE9SKSk7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCAmJiBjb25maWcuVFJBTlNQQVJFTlQpIGRyYXdDaGVja2VyYm9hcmQodGFyZ2V0KTtcbiAgZHJhd0Rpc3BsYXkodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gZHJhd0NvbG9yKHRhcmdldCwgY29sb3IpIHtcbiAgY29sb3JQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTRmKGNvbG9yUHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgMSk7XG4gIGJsaXQodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gZHJhd0NoZWNrZXJib2FyZCh0YXJnZXQpIHtcbiAgY2hlY2tlcmJvYXJkUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0xZihcbiAgICBjaGVja2VyYm9hcmRQcm9ncmFtLnVuaWZvcm1zLmFzcGVjdFJhdGlvLFxuICAgIGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHRcbiAgKTtcbiAgYmxpdCh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBkcmF3RGlzcGxheSh0YXJnZXQpIHtcbiAgbGV0IHdpZHRoID0gdGFyZ2V0ID09IG51bGwgPyBnbC5kcmF3aW5nQnVmZmVyV2lkdGggOiB0YXJnZXQud2lkdGg7XG4gIGxldCBoZWlnaHQgPSB0YXJnZXQgPT0gbnVsbCA/IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgOiB0YXJnZXQuaGVpZ2h0O1xuXG4gIGRpc3BsYXlNYXRlcmlhbC5iaW5kKCk7XG4gIGlmIChjb25maWcuU0hBRElORylcbiAgICBnbC51bmlmb3JtMmYoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnRleGVsU2l6ZSwgMS4wIC8gd2lkdGgsIDEuMCAvIGhlaWdodCk7XG4gIGdsLnVuaWZvcm0xaShkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudVRleHR1cmUsIGR5ZS5yZWFkLmF0dGFjaCgwKSk7XG4gIGlmIChjb25maWcuQkxPT00pIHtcbiAgICBnbC51bmlmb3JtMWkoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnVCbG9vbSwgYmxvb20uYXR0YWNoKDEpKTtcbiAgICBnbC51bmlmb3JtMWkoXG4gICAgICBkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudURpdGhlcmluZyxcbiAgICAgIGRpdGhlcmluZ1RleHR1cmUuYXR0YWNoKDIpXG4gICAgKTtcbiAgICBsZXQgc2NhbGUgPSBnZXRUZXh0dXJlU2NhbGUoZGl0aGVyaW5nVGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgZ2wudW5pZm9ybTJmKGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy5kaXRoZXJTY2FsZSwgc2NhbGUueCwgc2NhbGUueSk7XG4gIH1cbiAgaWYgKGNvbmZpZy5TVU5SQVlTKVxuICAgIGdsLnVuaWZvcm0xaShkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudVN1bnJheXMsIHN1bnJheXMuYXR0YWNoKDMpKTtcbiAgYmxpdCh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhcHBseUJsb29tKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgaWYgKGJsb29tRnJhbWVidWZmZXJzLmxlbmd0aCA8IDIpIHJldHVybjtcblxuICBsZXQgbGFzdCA9IGRlc3RpbmF0aW9uO1xuXG4gIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICBibG9vbVByZWZpbHRlclByb2dyYW0uYmluZCgpO1xuICBsZXQga25lZSA9IGNvbmZpZy5CTE9PTV9USFJFU0hPTEQgKiBjb25maWcuQkxPT01fU09GVF9LTkVFICsgMC4wMDAxO1xuICBsZXQgY3VydmUwID0gY29uZmlnLkJMT09NX1RIUkVTSE9MRCAtIGtuZWU7XG4gIGxldCBjdXJ2ZTEgPSBrbmVlICogMjtcbiAgbGV0IGN1cnZlMiA9IDAuMjUgLyBrbmVlO1xuICBnbC51bmlmb3JtM2YoYmxvb21QcmVmaWx0ZXJQcm9ncmFtLnVuaWZvcm1zLmN1cnZlLCBjdXJ2ZTAsIGN1cnZlMSwgY3VydmUyKTtcbiAgZ2wudW5pZm9ybTFmKFxuICAgIGJsb29tUHJlZmlsdGVyUHJvZ3JhbS51bmlmb3Jtcy50aHJlc2hvbGQsXG4gICAgY29uZmlnLkJMT09NX1RIUkVTSE9MRFxuICApO1xuICBnbC51bmlmb3JtMWkoYmxvb21QcmVmaWx0ZXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBzb3VyY2UuYXR0YWNoKDApKTtcbiAgYmxpdChsYXN0KTtcblxuICBibG9vbUJsdXJQcm9ncmFtLmJpbmQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9vbUZyYW1lYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBkZXN0ID0gYmxvb21GcmFtZWJ1ZmZlcnNbaV07XG4gICAgZ2wudW5pZm9ybTJmKFxuICAgICAgYmxvb21CbHVyUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICBsYXN0LnRleGVsU2l6ZVgsXG4gICAgICBsYXN0LnRleGVsU2l6ZVlcbiAgICApO1xuICAgIGdsLnVuaWZvcm0xaShibG9vbUJsdXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBsYXN0LmF0dGFjaCgwKSk7XG4gICAgYmxpdChkZXN0KTtcbiAgICBsYXN0ID0gZGVzdDtcbiAgfVxuXG4gIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG4gIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgZm9yIChsZXQgaSA9IGJsb29tRnJhbWVidWZmZXJzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGJhc2VUZXggPSBibG9vbUZyYW1lYnVmZmVyc1tpXTtcbiAgICBnbC51bmlmb3JtMmYoXG4gICAgICBibG9vbUJsdXJQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgIGxhc3QudGV4ZWxTaXplWCxcbiAgICAgIGxhc3QudGV4ZWxTaXplWVxuICAgICk7XG4gICAgZ2wudW5pZm9ybTFpKGJsb29tQmx1clByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIGxhc3QuYXR0YWNoKDApKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBiYXNlVGV4LndpZHRoLCBiYXNlVGV4LmhlaWdodCk7XG4gICAgYmxpdChiYXNlVGV4KTtcbiAgICBsYXN0ID0gYmFzZVRleDtcbiAgfVxuXG4gIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICBibG9vbUZpbmFsUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0yZihcbiAgICBibG9vbUZpbmFsUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgbGFzdC50ZXhlbFNpemVYLFxuICAgIGxhc3QudGV4ZWxTaXplWVxuICApO1xuICBnbC51bmlmb3JtMWkoYmxvb21GaW5hbFByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIGxhc3QuYXR0YWNoKDApKTtcbiAgZ2wudW5pZm9ybTFmKGJsb29tRmluYWxQcm9ncmFtLnVuaWZvcm1zLmludGVuc2l0eSwgY29uZmlnLkJMT09NX0lOVEVOU0lUWSk7XG4gIGJsaXQoZGVzdGluYXRpb24pO1xufVxuXG5mdW5jdGlvbiBhcHBseVN1bnJheXMoc291cmNlLCBtYXNrLCBkZXN0aW5hdGlvbikge1xuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgc3VucmF5c01hc2tQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTFpKHN1bnJheXNNYXNrUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgc291cmNlLmF0dGFjaCgwKSk7XG4gIGJsaXQobWFzayk7XG5cbiAgc3VucmF5c1Byb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMWYoc3VucmF5c1Byb2dyYW0udW5pZm9ybXMud2VpZ2h0LCBjb25maWcuU1VOUkFZU19XRUlHSFQpO1xuICBnbC51bmlmb3JtMWkoc3VucmF5c1Byb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIG1hc2suYXR0YWNoKDApKTtcbiAgYmxpdChkZXN0aW5hdGlvbik7XG59XG5cbmZ1bmN0aW9uIGJsdXIodGFyZ2V0LCB0ZW1wLCBpdGVyYXRpb25zKSB7XG4gIGJsdXJQcm9ncmFtLmJpbmQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICBnbC51bmlmb3JtMmYoYmx1clByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLCB0YXJnZXQudGV4ZWxTaXplWCwgMC4wKTtcbiAgICBnbC51bmlmb3JtMWkoYmx1clByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHRhcmdldC5hdHRhY2goMCkpO1xuICAgIGJsaXQodGVtcCk7XG5cbiAgICBnbC51bmlmb3JtMmYoYmx1clByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLCAwLjAsIHRhcmdldC50ZXhlbFNpemVZKTtcbiAgICBnbC51bmlmb3JtMWkoYmx1clByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHRlbXAuYXR0YWNoKDApKTtcbiAgICBibGl0KHRhcmdldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsYXRQb2ludGVyKHBvaW50ZXIpIHtcbiAgbGV0IGR4ID0gcG9pbnRlci5kZWx0YVggKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gIGxldCBkeSA9IHBvaW50ZXIuZGVsdGFZICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICBzcGxhdChwb2ludGVyLnRleGNvb3JkWCwgcG9pbnRlci50ZXhjb29yZFksIGR4LCBkeSwgcG9pbnRlci5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlU3BsYXRzKGFtb3VudCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgY29uc3QgY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgY29sb3IuciAqPSAxMC4wO1xuICAgIGNvbG9yLmcgKj0gMTAuMDtcbiAgICBjb2xvci5iICo9IDEwLjA7XG4gICAgY29uc3QgeCA9IE1hdGgucmFuZG9tKCk7XG4gICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCk7XG4gICAgY29uc3QgZHggPSAxMDAwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgIGNvbnN0IGR5ID0gMTAwMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICBzcGxhdCh4LCB5LCBkeCwgZHksIGNvbG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxhdCh4LCB5LCBkeCwgZHksIGNvbG9yKSB7XG4gIHNwbGF0UHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpO1xuICBnbC51bmlmb3JtMWYoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmFzcGVjdFJhdGlvLCBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0KTtcbiAgZ2wudW5pZm9ybTJmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5wb2ludCwgeCwgeSk7XG4gIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGR4LCBkeSwgMC4wKTtcbiAgZ2wudW5pZm9ybTFmKFxuICAgIHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5yYWRpdXMsXG4gICAgY29ycmVjdFJhZGl1cyhjb25maWcuU1BMQVRfUkFESVVTIC8gMTAwLjApXG4gICk7XG4gIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgZ2wudW5pZm9ybTFpKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy51VGFyZ2V0LCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICBnbC51bmlmb3JtM2Yoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmNvbG9yLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgYmxpdChkeWUud3JpdGUpO1xuICBkeWUuc3dhcCgpO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0UmFkaXVzKHJhZGl1cykge1xuICBsZXQgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICBpZiAoYXNwZWN0UmF0aW8gPiAxKSByYWRpdXMgKj0gYXNwZWN0UmF0aW87XG4gIHJldHVybiByYWRpdXM7XG59XG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUub2Zmc2V0WCk7XG4gIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5vZmZzZXRZKTtcbiAgbGV0IHBvaW50ZXIgPSBwb2ludGVycy5maW5kKChwKSA9PiBwLmlkID09IC0xKTtcbiAgaWYgKHBvaW50ZXIgPT0gbnVsbCkgcG9pbnRlciA9IG5ldyBwb2ludGVyUHJvdG90eXBlKCk7XG4gIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCAtMSwgcG9zWCwgcG9zWSk7XG59KTtcblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gIGxldCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gIGlmICghcG9pbnRlci5kb3duKSByZXR1cm47XG4gIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5vZmZzZXRYKTtcbiAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLm9mZnNldFkpO1xuICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSk7XG59KTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG4gIHVwZGF0ZVBvaW50ZXJVcERhdGEocG9pbnRlcnNbMF0pO1xufSk7XG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGUpID0+IHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICB3aGlsZSAodG91Y2hlcy5sZW5ndGggPj0gcG9pbnRlcnMubGVuZ3RoKVxuICAgIHBvaW50ZXJzLnB1c2gobmV3IHBvaW50ZXJQcm90b3R5cGUoKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5wYWdlWCk7XG4gICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLnBhZ2VZKTtcbiAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlcnNbaSArIDFdLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHBvc1gsIHBvc1kpO1xuICB9XG59KTtcblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICd0b3VjaG1vdmUnLFxuICAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1tpICsgMV07XG4gICAgICBpZiAoIXBvaW50ZXIuZG93bikgY29udGludWU7XG4gICAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0ucGFnZVgpO1xuICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLnBhZ2VZKTtcbiAgICAgIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyLCBwb3NYLCBwb3NZKTtcbiAgICB9XG4gIH0sXG4gIGZhbHNlXG4pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoZSkgPT4ge1xuICBjb25zdCB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBvaW50ZXIgPSBwb2ludGVycy5maW5kKChwKSA9PiBwLmlkID09IHRvdWNoZXNbaV0uaWRlbnRpZmllcik7XG4gICAgaWYgKHBvaW50ZXIgPT0gbnVsbCkgY29udGludWU7XG4gICAgdXBkYXRlUG9pbnRlclVwRGF0YShwb2ludGVyKTtcbiAgfVxufSk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgaWYgKGUuY29kZSA9PT0gJ0tleVAnKSBjb25maWcuUEFVU0VEID0gIWNvbmZpZy5QQVVTRUQ7XG4gIGlmIChlLmtleSA9PT0gJyAnKSBzcGxhdFN0YWNrLnB1c2gocGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDIwKSArIDUpO1xufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCBpZCwgcG9zWCwgcG9zWSkge1xuICBwb2ludGVyLmlkID0gaWQ7XG4gIHBvaW50ZXIuZG93biA9IHRydWU7XG4gIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzLndpZHRoO1xuICBwb2ludGVyLnRleGNvb3JkWSA9IDEuMCAtIHBvc1kgLyBjYW52YXMuaGVpZ2h0O1xuICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XG4gIHBvaW50ZXIuZGVsdGFYID0gMDtcbiAgcG9pbnRlci5kZWx0YVkgPSAwO1xuICBwb2ludGVyLmNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSkge1xuICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XG4gIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcy53aWR0aDtcbiAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodDtcbiAgcG9pbnRlci5kZWx0YVggPSBjb3JyZWN0RGVsdGFYKHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYKTtcbiAgcG9pbnRlci5kZWx0YVkgPSBjb3JyZWN0RGVsdGFZKHBvaW50ZXIudGV4Y29vcmRZIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRZKTtcbiAgcG9pbnRlci5tb3ZlZCA9IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9pbnRlclVwRGF0YShwb2ludGVyKSB7XG4gIHBvaW50ZXIuZG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0RGVsdGFYKGRlbHRhKSB7XG4gIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gIGlmIChhc3BlY3RSYXRpbyA8IDEpIGRlbHRhICo9IGFzcGVjdFJhdGlvO1xuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3REZWx0YVkoZGVsdGEpIHtcbiAgbGV0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgaWYgKGFzcGVjdFJhdGlvID4gMSkgZGVsdGEgLz0gYXNwZWN0UmF0aW87XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcigpIHtcbiAgbGV0IGMgPSBIU1Z0b1JHQihNYXRoLnJhbmRvbSgpLCAxLjAsIDEuMCk7XG4gIGMuciAqPSAwLjE1O1xuICBjLmcgKj0gMC4xNTtcbiAgYy5iICo9IDAuMTU7XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBIU1Z0b1JHQihoLCBzLCB2KSB7XG4gIGxldCByLCBnLCBiLCBpLCBmLCBwLCBxLCB0O1xuICBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIGYgPSBoICogNiAtIGk7XG4gIHAgPSB2ICogKDEgLSBzKTtcbiAgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOlxuICAgICAgKHIgPSB2KSwgKGcgPSB0KSwgKGIgPSBwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIChyID0gcSksIChnID0gdiksIChiID0gcCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICAociA9IHApLCAoZyA9IHYpLCAoYiA9IHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgKHIgPSBwKSwgKGcgPSBxKSwgKGIgPSB2KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIChyID0gdCksIChnID0gcCksIChiID0gdik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICAociA9IHYpLCAoZyA9IHApLCAoYiA9IHEpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHIsXG4gICAgZyxcbiAgICBiLFxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihpbnB1dCkge1xuICBsZXQgb3V0cHV0ID0ge1xuICAgIHI6IGlucHV0LnIgLyAyNTUsXG4gICAgZzogaW5wdXQuZyAvIDI1NSxcbiAgICBiOiBpbnB1dC5iIC8gMjU1LFxuICB9O1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiB3cmFwKHZhbHVlLCBtaW4sIG1heCkge1xuICBsZXQgcmFuZ2UgPSBtYXggLSBtaW47XG4gIGlmIChyYW5nZSA9PSAwKSByZXR1cm4gbWluO1xuICByZXR1cm4gKCh2YWx1ZSAtIG1pbikgJSByYW5nZSkgKyBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICBsZXQgYXNwZWN0UmF0aW8gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGggLyBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBhc3BlY3RSYXRpbyA9IDEuMCAvIGFzcGVjdFJhdGlvO1xuXG4gIGxldCBtaW4gPSBNYXRoLnJvdW5kKHJlc29sdXRpb24pO1xuICBsZXQgbWF4ID0gTWF0aC5yb3VuZChyZXNvbHV0aW9uICogYXNwZWN0UmF0aW8pO1xuXG4gIGlmIChnbC5kcmF3aW5nQnVmZmVyV2lkdGggPiBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KVxuICAgIHJldHVybiB7IHdpZHRoOiBtYXgsIGhlaWdodDogbWluIH07XG4gIGVsc2UgcmV0dXJuIHsgd2lkdGg6IG1pbiwgaGVpZ2h0OiBtYXggfTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVNjYWxlKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB3aWR0aCAvIHRleHR1cmUud2lkdGgsXG4gICAgeTogaGVpZ2h0IC8gdGV4dHVyZS5oZWlnaHQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYWxlQnlQaXhlbFJhdGlvKGlucHV0KSB7XG4gIGxldCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5wdXQgKiBwaXhlbFJhdGlvKTtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUocykge1xuICBpZiAocy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gIGxldCBoYXNoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIHMuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG4gIHJldHVybiBoYXNoO1xufVxuIl0sIm5hbWVzIjpbImRvY3VtZW50Iiwid2luZG93IiwiY2FudmFzIiwiZ2V0RWxlbWVudEJ5SWQiLCJjb25zb2xlIiwibG9nIiwicmVzaXplQ2FudmFzIiwiY29uZmlnIiwiU0lNX1JFU09MVVRJT04iLCJEWUVfUkVTT0xVVElPTiIsIkNBUFRVUkVfUkVTT0xVVElPTiIsIkRFTlNJVFlfRElTU0lQQVRJT04iLCJWRUxPQ0lUWV9ESVNTSVBBVElPTiIsIlBSRVNTVVJFIiwiUFJFU1NVUkVfSVRFUkFUSU9OUyIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJTUExBVF9GT1JDRSIsIlNIQURJTkciLCJDT0xPUkZVTCIsIkNPTE9SX1VQREFURV9TUEVFRCIsIlBBVVNFRCIsIkJBQ0tfQ09MT1IiLCJyIiwiZyIsImIiLCJUUkFOU1BBUkVOVCIsIkJMT09NIiwiQkxPT01fSVRFUkFUSU9OUyIsIkJMT09NX1JFU09MVVRJT04iLCJCTE9PTV9JTlRFTlNJVFkiLCJCTE9PTV9USFJFU0hPTEQiLCJCTE9PTV9TT0ZUX0tORUUiLCJTVU5SQVlTIiwiU1VOUkFZU19SRVNPTFVUSU9OIiwiU1VOUkFZU19XRUlHSFQiLCJwb2ludGVyUHJvdG90eXBlIiwiaWQiLCJ0ZXhjb29yZFgiLCJ0ZXhjb29yZFkiLCJwcmV2VGV4Y29vcmRYIiwicHJldlRleGNvb3JkWSIsImRlbHRhWCIsImRlbHRhWSIsImRvd24iLCJtb3ZlZCIsImNvbG9yIiwicG9pbnRlcnMiLCJzcGxhdFN0YWNrIiwicHVzaCIsImdsIiwiZXh0IiwiZ2V0V2ViR0xDb250ZXh0IiwiaXNNb2JpbGUiLCJzdXBwb3J0TGluZWFyRmlsdGVyaW5nIiwicGFyYW1zIiwiYWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJnZXRDb250ZXh0IiwiaXNXZWJHTDIiLCJoYWxmRmxvYXQiLCJnZXRFeHRlbnNpb24iLCJjbGVhckNvbG9yIiwiaGFsZkZsb2F0VGV4VHlwZSIsIkhBTEZfRkxPQVQiLCJIQUxGX0ZMT0FUX09FUyIsImZvcm1hdFJHQkEiLCJmb3JtYXRSRyIsImZvcm1hdFIiLCJnZXRTdXBwb3J0ZWRGb3JtYXQiLCJSR0JBMTZGIiwiUkdCQSIsIlJHMTZGIiwiUkciLCJSMTZGIiwiUkVEIiwiaW50ZXJuYWxGb3JtYXQiLCJmb3JtYXQiLCJ0eXBlIiwic3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQiLCJ0ZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJORUFSRVNUIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJ0ZXhJbWFnZTJEIiwiZmJvIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJzdGF0dXMiLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY2FwdHVyZVNjcmVlbnNob3QiLCJyZXMiLCJnZXRSZXNvbHV0aW9uIiwidGFyZ2V0IiwiY3JlYXRlRkJPIiwid2lkdGgiLCJoZWlnaHQiLCJyZW5kZXIiLCJmcmFtZWJ1ZmZlclRvVGV4dHVyZSIsIm5vcm1hbGl6ZVRleHR1cmUiLCJjYXB0dXJlQ2FudmFzIiwidGV4dHVyZVRvQ2FudmFzIiwiZGF0YXVyaSIsInRvRGF0YVVSTCIsImRvd25sb2FkVVJJIiwiVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwibGVuZ3RoIiwiRmxvYXQzMkFycmF5IiwicmVhZFBpeGVscyIsIkZMT0FUIiwicmVzdWx0IiwiVWludDhBcnJheSIsImkiLCJqIiwibmlkIiwiY2xhbXAwMSIsImlucHV0IiwiTWF0aCIsIm1pbiIsIm1heCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJpbWFnZURhdGEiLCJjcmVhdGVJbWFnZURhdGEiLCJkYXRhIiwic2V0IiwicHV0SW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ1cmkiLCJsaW5rIiwiZG93bmxvYWQiLCJocmVmIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsIk1hdGVyaWFsIiwic2V0S2V5d29yZHMiLCJrZXl3b3JkcyIsImhhc2giLCJoYXNoQ29kZSIsInByb2dyYW0iLCJwcm9ncmFtcyIsImZyYWdtZW50U2hhZGVyIiwiY29tcGlsZVNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsImZyYWdtZW50U2hhZGVyU291cmNlIiwiY3JlYXRlUHJvZ3JhbSIsInZlcnRleFNoYWRlciIsImFjdGl2ZVByb2dyYW0iLCJ1bmlmb3JtcyIsImdldFVuaWZvcm1zIiwiYmluZCIsInVzZVByb2dyYW0iLCJjb25zdHJ1Y3RvciIsIlByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsInRyYWNlIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJ1bmlmb3JtQ291bnQiLCJBQ1RJVkVfVU5JRk9STVMiLCJ1bmlmb3JtTmFtZSIsImdldEFjdGl2ZVVuaWZvcm0iLCJuYW1lIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwic291cmNlIiwiYWRkS2V5d29yZHMiLCJzaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJrZXl3b3Jkc1N0cmluZyIsImZvckVhY2giLCJrZXl3b3JkIiwiYmFzZVZlcnRleFNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJibHVyVmVydGV4U2hhZGVyIiwiYmx1clNoYWRlciIsImNvcHlTaGFkZXIiLCJjbGVhclNoYWRlciIsImNvbG9yU2hhZGVyIiwiY2hlY2tlcmJvYXJkU2hhZGVyIiwiZGlzcGxheVNoYWRlclNvdXJjZSIsImJsb29tUHJlZmlsdGVyU2hhZGVyIiwiYmxvb21CbHVyU2hhZGVyIiwiYmxvb21GaW5hbFNoYWRlciIsInN1bnJheXNNYXNrU2hhZGVyIiwic3VucmF5c1NoYWRlciIsInNwbGF0U2hhZGVyIiwiYWR2ZWN0aW9uU2hhZGVyIiwiZGl2ZXJnZW5jZVNoYWRlciIsImN1cmxTaGFkZXIiLCJ2b3J0aWNpdHlTaGFkZXIiLCJwcmVzc3VyZVNoYWRlciIsImdyYWRpZW50U3VidHJhY3RTaGFkZXIiLCJibGl0IiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImNyZWF0ZUJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiVWludDE2QXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJjbGVhciIsInZpZXdwb3J0IiwiZHJhd2luZ0J1ZmZlcldpZHRoIiwiZHJhd2luZ0J1ZmZlckhlaWdodCIsIkNPTE9SX0JVRkZFUl9CSVQiLCJkcmF3RWxlbWVudHMiLCJUUklBTkdMRVMiLCJVTlNJR05FRF9TSE9SVCIsIkNIRUNLX0ZSQU1FQlVGRkVSX1NUQVRVUyIsImR5ZSIsInZlbG9jaXR5IiwiZGl2ZXJnZW5jZSIsImN1cmwiLCJwcmVzc3VyZSIsImJsb29tIiwiYmxvb21GcmFtZWJ1ZmZlcnMiLCJzdW5yYXlzIiwic3VucmF5c1RlbXAiLCJkaXRoZXJpbmdUZXh0dXJlIiwiY3JlYXRlVGV4dHVyZUFzeW5jIiwiYmx1clByb2dyYW0iLCJjb3B5UHJvZ3JhbSIsImNsZWFyUHJvZ3JhbSIsImNvbG9yUHJvZ3JhbSIsImNoZWNrZXJib2FyZFByb2dyYW0iLCJibG9vbVByZWZpbHRlclByb2dyYW0iLCJibG9vbUJsdXJQcm9ncmFtIiwiYmxvb21GaW5hbFByb2dyYW0iLCJzdW5yYXlzTWFza1Byb2dyYW0iLCJzdW5yYXlzUHJvZ3JhbSIsInNwbGF0UHJvZ3JhbSIsImFkdmVjdGlvblByb2dyYW0iLCJkaXZlcmdlbmNlUHJvZ3JhbSIsImN1cmxQcm9ncmFtIiwidm9ydGljaXR5UHJvZ3JhbSIsInByZXNzdXJlUHJvZ3JhbSIsImdyYWRpZW5TdWJ0cmFjdFByb2dyYW0iLCJkaXNwbGF5TWF0ZXJpYWwiLCJpbml0RnJhbWVidWZmZXJzIiwic2ltUmVzIiwiZHllUmVzIiwidGV4VHlwZSIsInJnYmEiLCJyZyIsImZpbHRlcmluZyIsIkxJTkVBUiIsImRpc2FibGUiLCJCTEVORCIsImNyZWF0ZURvdWJsZUZCTyIsInJlc2l6ZURvdWJsZUZCTyIsImluaXRCbG9vbUZyYW1lYnVmZmVycyIsImluaXRTdW5yYXlzRnJhbWVidWZmZXJzIiwidyIsImgiLCJwYXJhbSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInRleGVsU2l6ZVgiLCJ0ZXhlbFNpemVZIiwiYXR0YWNoIiwiZmJvMSIsImZibzIiLCJyZWFkIiwidmFsdWUiLCJ3cml0ZSIsInN3YXAiLCJ0ZW1wIiwicmVzaXplRkJPIiwibmV3RkJPIiwidW5pZm9ybTFpIiwidVRleHR1cmUiLCJ1cmwiLCJSRVBFQVQiLCJSR0IiLCJVTlNJR05FRF9CWVRFIiwib2JqIiwiaW1hZ2UiLCJJbWFnZSIsIm9ubG9hZCIsInNyYyIsInVwZGF0ZUtleXdvcmRzIiwiZGlzcGxheUtleXdvcmRzIiwibXVsdGlwbGVTcGxhdHMiLCJwYXJzZUludCIsInJhbmRvbSIsImxhc3RVcGRhdGVUaW1lIiwiRGF0ZSIsIm5vdyIsImNvbG9yVXBkYXRlVGltZXIiLCJ1cGRhdGUiLCJkdCIsImNhbGNEZWx0YVRpbWUiLCJ1cGRhdGVDb2xvcnMiLCJhcHBseUlucHV0cyIsInN0ZXAiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY2FsZUJ5UGl4ZWxSYXRpbyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwid3JhcCIsInAiLCJnZW5lcmF0ZUNvbG9yIiwicG9wIiwic3BsYXRQb2ludGVyIiwidW5pZm9ybTJmIiwidGV4ZWxTaXplIiwidVZlbG9jaXR5IiwidUN1cmwiLCJ1bmlmb3JtMWYiLCJ1RGl2ZXJnZW5jZSIsInVQcmVzc3VyZSIsImR5ZVRleGVsU2l6ZSIsInZlbG9jaXR5SWQiLCJ1U291cmNlIiwiZGlzc2lwYXRpb24iLCJhcHBseUJsb29tIiwiYXBwbHlTdW5yYXlzIiwiYmx1ciIsImJsZW5kRnVuYyIsIk9ORSIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJlbmFibGUiLCJkcmF3Q29sb3IiLCJub3JtYWxpemVDb2xvciIsImRyYXdDaGVja2VyYm9hcmQiLCJkcmF3RGlzcGxheSIsInVuaWZvcm00ZiIsImFzcGVjdFJhdGlvIiwidUJsb29tIiwidURpdGhlcmluZyIsInNjYWxlIiwiZ2V0VGV4dHVyZVNjYWxlIiwiZGl0aGVyU2NhbGUiLCJ4IiwieSIsInVTdW5yYXlzIiwiZGVzdGluYXRpb24iLCJsYXN0Iiwia25lZSIsImN1cnZlMCIsImN1cnZlMSIsImN1cnZlMiIsInVuaWZvcm0zZiIsImN1cnZlIiwidGhyZXNob2xkIiwiZGVzdCIsImJhc2VUZXgiLCJpbnRlbnNpdHkiLCJtYXNrIiwid2VpZ2h0IiwiaXRlcmF0aW9ucyIsInBvaW50ZXIiLCJkeCIsImR5Iiwic3BsYXQiLCJhbW91bnQiLCJ1VGFyZ2V0IiwicG9pbnQiLCJyYWRpdXMiLCJjb3JyZWN0UmFkaXVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwb3NYIiwib2Zmc2V0WCIsInBvc1kiLCJvZmZzZXRZIiwiZmluZCIsInVwZGF0ZVBvaW50ZXJEb3duRGF0YSIsInVwZGF0ZVBvaW50ZXJNb3ZlRGF0YSIsInVwZGF0ZVBvaW50ZXJVcERhdGEiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwicGFnZVgiLCJwYWdlWSIsImlkZW50aWZpZXIiLCJjaGFuZ2VkVG91Y2hlcyIsImNvZGUiLCJrZXkiLCJjb3JyZWN0RGVsdGFYIiwiY29ycmVjdERlbHRhWSIsImFicyIsImRlbHRhIiwiYyIsIkhTVnRvUkdCIiwicyIsInYiLCJmIiwicSIsInQiLCJmbG9vciIsIm91dHB1dCIsInJhbmdlIiwicmVzb2x1dGlvbiIsInJvdW5kIiwicGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJjaGFyQ29kZUF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./shared/lib/webgl.js\n"));

/***/ })

});