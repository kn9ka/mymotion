"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./shared/lib/webgl.js":
/*!*****************************!*\
  !*** ./shared/lib/webgl.js ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\nMIT License\nCopyright (c) 2017 Pavel Dobryakov\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/ \n// Simulation section\nlet document = window.document;\nconst canvas = document.getElementById(\"smoke-webgl\");\nresizeCanvas();\nlet config = {\n    SIM_RESOLUTION: 128,\n    DYE_RESOLUTION: 1024,\n    CAPTURE_RESOLUTION: 512,\n    DENSITY_DISSIPATION: 1,\n    VELOCITY_DISSIPATION: 0.2,\n    PRESSURE: 0.8,\n    PRESSURE_ITERATIONS: 20,\n    CURL: 30,\n    SPLAT_RADIUS: 0.25,\n    SPLAT_FORCE: 6000,\n    SHADING: true,\n    COLORFUL: true,\n    COLOR_UPDATE_SPEED: 10,\n    PAUSED: false,\n    BACK_COLOR: {\n        r: 0,\n        g: 0,\n        b: 0\n    },\n    TRANSPARENT: false,\n    BLOOM: true,\n    BLOOM_ITERATIONS: 8,\n    BLOOM_RESOLUTION: 256,\n    BLOOM_INTENSITY: 0.8,\n    BLOOM_THRESHOLD: 0.6,\n    BLOOM_SOFT_KNEE: 0.7,\n    SUNRAYS: true,\n    SUNRAYS_RESOLUTION: 196,\n    SUNRAYS_WEIGHT: 1.0\n};\nfunction pointerPrototype() {\n    this.id = -1;\n    this.texcoordX = 0;\n    this.texcoordY = 0;\n    this.prevTexcoordX = 0;\n    this.prevTexcoordY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.down = false;\n    this.moved = false;\n    this.color = [\n        30,\n        0,\n        300\n    ];\n}\nlet pointers = [];\nlet splatStack = [];\npointers.push(new pointerPrototype());\nconst { gl , ext  } = getWebGLContext(canvas);\nif (isMobile()) {\n    config.DYE_RESOLUTION = 512;\n}\nif (!ext.supportLinearFiltering) {\n    config.DYE_RESOLUTION = 512;\n    config.SHADING = false;\n    config.BLOOM = false;\n    config.SUNRAYS = false;\n}\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n    };\n    let gl = canvas.getContext(\"webgl2\", params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2) gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n    let halfFloat;\n    let supportLinearFiltering;\n    if (isWebGL2) {\n        gl.getExtension(\"EXT_color_buffer_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n    } else {\n        halfFloat = gl.getExtension(\"OES_texture_half_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_half_float_linear\");\n    }\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;\n    let formatRGBA;\n    let formatRG;\n    let formatR;\n    if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n    } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    }\n    return {\n        gl,\n        ext: {\n            formatRGBA,\n            formatRG,\n            formatR,\n            halfFloatTexType,\n            supportLinearFiltering\n        }\n    };\n}\nfunction getSupportedFormat(gl, internalFormat, format, type) {\n    if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch(internalFormat){\n            case gl.R16F:\n                return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n            case gl.RG16F:\n                return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n            default:\n                return null;\n        }\n    }\n    return {\n        internalFormat,\n        format\n    };\n}\nfunction supportRenderTextureFormat(gl, internalFormat, format, type) {\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    return status == gl.FRAMEBUFFER_COMPLETE;\n}\nfunction isMobile() {\n    return /Mobi|Android/i.test(navigator.userAgent);\n}\nfunction captureScreenshot() {\n    let res = getResolution(config.CAPTURE_RESOLUTION);\n    let target = createFBO(res.width, res.height, ext.formatRGBA.internalFormat, ext.formatRGBA.format, ext.halfFloatTexType, gl.NEAREST);\n    render(target);\n    let texture = framebufferToTexture(target);\n    texture = normalizeTexture(texture, target.width, target.height);\n    let captureCanvas = textureToCanvas(texture, target.width, target.height);\n    let datauri = captureCanvas.toDataURL();\n    downloadURI(\"fluid.png\", datauri);\n    URL.revokeObjectURL(datauri);\n}\nfunction framebufferToTexture(target) {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n    let length = target.width * target.height * 4;\n    let texture = new Float32Array(length);\n    gl.readPixels(0, 0, target.width, target.height, gl.RGBA, gl.FLOAT, texture);\n    return texture;\n}\nfunction normalizeTexture(texture, width, height) {\n    let result = new Uint8Array(texture.length);\n    let id = 0;\n    for(let i = height - 1; i >= 0; i--){\n        for(let j = 0; j < width; j++){\n            let nid = i * width * 4 + j * 4;\n            result[nid + 0] = clamp01(texture[id + 0]) * 255;\n            result[nid + 1] = clamp01(texture[id + 1]) * 255;\n            result[nid + 2] = clamp01(texture[id + 2]) * 255;\n            result[nid + 3] = clamp01(texture[id + 3]) * 255;\n            id += 4;\n        }\n    }\n    return result;\n}\nfunction clamp01(input) {\n    return Math.min(Math.max(input, 0), 1);\n}\nfunction textureToCanvas(texture, width, height) {\n    let captureCanvas = document.createElement(\"canvas\");\n    let ctx = captureCanvas.getContext(\"2d\");\n    captureCanvas.width = width;\n    captureCanvas.height = height;\n    let imageData = ctx.createImageData(width, height);\n    imageData.data.set(texture);\n    ctx.putImageData(imageData, 0, 0);\n    return captureCanvas;\n}\nfunction downloadURI(filename, uri) {\n    let link = document.createElement(\"a\");\n    link.download = filename;\n    link.href = uri;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\nclass Material {\n    setKeywords(keywords) {\n        let hash = 0;\n        for(let i = 0; i < keywords.length; i++)hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n            let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n            program = createProgram(this.vertexShader, fragmentShader);\n            this.programs[hash] = program;\n        }\n        if (program == this.activeProgram) return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n    }\n    bind() {\n        gl.useProgram(this.activeProgram);\n    }\n    constructor(vertexShader, fragmentShaderSource){\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = [];\n    }\n}\nclass Program {\n    bind() {\n        gl.useProgram(this.program);\n    }\n    constructor(vertexShader, fragmentShader){\n        this.uniforms = {};\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n    }\n}\nfunction createProgram(vertexShader, fragmentShader) {\n    let program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n    return program;\n}\nfunction getUniforms(program) {\n    let uniforms = [];\n    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for(let i = 0; i < uniformCount; i++){\n        let uniformName = gl.getActiveUniform(program, i).name;\n        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n    }\n    return uniforms;\n}\nfunction compileShader(type, source, keywords) {\n    source = addKeywords(source, keywords);\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n    return shader;\n}\nfunction addKeywords(source, keywords) {\n    if (keywords == null) return source;\n    let keywordsString = \"\";\n    keywords.forEach((keyword)=>{\n        keywordsString += \"#define \" + keyword + \"\\n\";\n    });\n    return keywordsString + source;\n}\nconst baseVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n    precision highp float;\\n    attribute vec2 aPosition;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform vec2 texelSize;\\n    void main () {\\n        vUv = aPosition * 0.5 + 0.5;\\n        vL = vUv - vec2(texelSize.x, 0.0);\\n        vR = vUv + vec2(texelSize.x, 0.0);\\n        vT = vUv + vec2(0.0, texelSize.y);\\n        vB = vUv - vec2(0.0, texelSize.y);\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n    }\\n\");\nconst blurVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n    precision highp float;\\n    attribute vec2 aPosition;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    uniform vec2 texelSize;\\n    void main () {\\n        vUv = aPosition * 0.5 + 0.5;\\n        float offset = 1.33333333;\\n        vL = vUv - texelSize * offset;\\n        vR = vUv + texelSize * offset;\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n    }\\n\");\nconst blurShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        vec4 sum = texture2D(uTexture, vUv) * 0.29411764;\\n        sum += texture2D(uTexture, vL) * 0.35294117;\\n        sum += texture2D(uTexture, vR) * 0.35294117;\\n        gl_FragColor = sum;\\n    }\\n\");\nconst copyShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        gl_FragColor = texture2D(uTexture, vUv);\\n    }\\n\");\nconst clearShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform float value;\\n    void main () {\\n        gl_FragColor = value * texture2D(uTexture, vUv);\\n    }\\n\");\nconst colorShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    uniform vec4 color;\\n    void main () {\\n        gl_FragColor = color;\\n    }\\n\");\nconst checkerboardShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform float aspectRatio;\\n    #define SCALE 25.0\\n    void main () {\\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\\n        float v = mod(uv.x + uv.y, 2.0);\\n        v = v * 0.1 + 0.8;\\n        gl_FragColor = vec4(vec3(v), 1.0);\\n    }\\n\");\nconst displayShaderSource = \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uTexture;\\n    uniform sampler2D uBloom;\\n    uniform sampler2D uSunrays;\\n    uniform sampler2D uDithering;\\n    uniform vec2 ditherScale;\\n    uniform vec2 texelSize;\\n    vec3 linearToGamma (vec3 color) {\\n        color = max(color, vec3(0));\\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n    }\\n    void main () {\\n        vec3 c = texture2D(uTexture, vUv).rgb;\\n    #ifdef SHADING\\n        vec3 lc = texture2D(uTexture, vL).rgb;\\n        vec3 rc = texture2D(uTexture, vR).rgb;\\n        vec3 tc = texture2D(uTexture, vT).rgb;\\n        vec3 bc = texture2D(uTexture, vB).rgb;\\n        float dx = length(rc) - length(lc);\\n        float dy = length(tc) - length(bc);\\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n        vec3 l = vec3(0.0, 0.0, 1.0);\\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n        c *= diffuse;\\n    #endif\\n    #ifdef BLOOM\\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\\n    #endif\\n    #ifdef SUNRAYS\\n        float sunrays = texture2D(uSunrays, vUv).r;\\n        c *= sunrays;\\n    #ifdef BLOOM\\n        bloom *= sunrays;\\n    #endif\\n    #endif\\n    #ifdef BLOOM\\n        float noise = texture2D(uDithering, vUv * ditherScale).r;\\n        noise = noise * 2.0 - 1.0;\\n        bloom += noise / 255.0;\\n        bloom = linearToGamma(bloom);\\n        c += bloom;\\n    #endif\\n        float a = max(c.r, max(c.g, c.b));\\n        gl_FragColor = vec4(c, a);\\n    }\\n\";\nconst bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform vec3 curve;\\n    uniform float threshold;\\n    void main () {\\n        vec3 c = texture2D(uTexture, vUv).rgb;\\n        float br = max(c.r, max(c.g, c.b));\\n        float rq = clamp(br - curve.x, 0.0, curve.y);\\n        rq = curve.z * rq * rq;\\n        c *= max(rq, br - threshold) / max(br, 0.0001);\\n        gl_FragColor = vec4(c, 0.0);\\n    }\\n\");\nconst bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        vec4 sum = vec4(0.0);\\n        sum += texture2D(uTexture, vL);\\n        sum += texture2D(uTexture, vR);\\n        sum += texture2D(uTexture, vT);\\n        sum += texture2D(uTexture, vB);\\n        sum *= 0.25;\\n        gl_FragColor = sum;\\n    }\\n\");\nconst bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uTexture;\\n    uniform float intensity;\\n    void main () {\\n        vec4 sum = vec4(0.0);\\n        sum += texture2D(uTexture, vL);\\n        sum += texture2D(uTexture, vR);\\n        sum += texture2D(uTexture, vT);\\n        sum += texture2D(uTexture, vB);\\n        sum *= 0.25;\\n        gl_FragColor = sum * intensity;\\n    }\\n\");\nconst sunraysMaskShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    void main () {\\n        vec4 c = texture2D(uTexture, vUv);\\n        float br = max(c.r, max(c.g, c.b));\\n        c.a = 1.0 - min(max(br * 20.0, 0.0), 0.8);\\n        gl_FragColor = c;\\n    }\\n\");\nconst sunraysShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTexture;\\n    uniform float weight;\\n    #define ITERATIONS 16\\n    void main () {\\n        float Density = 0.3;\\n        float Decay = 0.95;\\n        float Exposure = 0.7;\\n        vec2 coord = vUv;\\n        vec2 dir = vUv - 0.5;\\n        dir *= 1.0 / float(ITERATIONS) * Density;\\n        float illuminationDecay = 1.0;\\n        float color = texture2D(uTexture, vUv).a;\\n        for (int i = 0; i < ITERATIONS; i++)\\n        {\\n            coord -= dir;\\n            float col = texture2D(uTexture, coord).a;\\n            color += col * illuminationDecay * weight;\\n            illuminationDecay *= Decay;\\n        }\\n        gl_FragColor = vec4(color * Exposure, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst splatShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uTarget;\\n    uniform float aspectRatio;\\n    uniform vec3 color;\\n    uniform vec2 point;\\n    uniform float radius;\\n    void main () {\\n        vec2 p = vUv - point.xy;\\n        p.x *= aspectRatio;\\n        vec3 splat = exp(-dot(p, p) / radius) * color;\\n        vec3 base = texture2D(uTarget, vUv).xyz;\\n        gl_FragColor = vec4(base + splat, 1.0);\\n    }\\n\");\nconst advectionShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    uniform sampler2D uVelocity;\\n    uniform sampler2D uSource;\\n    uniform vec2 texelSize;\\n    uniform vec2 dyeTexelSize;\\n    uniform float dt;\\n    uniform float dissipation;\\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n        vec2 st = uv / tsize - 0.5;\\n        vec2 iuv = floor(st);\\n        vec2 fuv = fract(st);\\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n    }\\n    void main () {\\n    #ifdef MANUAL_FILTERING\\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n        vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n    #else\\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n        vec4 result = texture2D(uSource, coord);\\n    #endif\\n        float decay = 1.0 + dissipation * dt;\\n        gl_FragColor = result / decay;\\n    }\", ext.supportLinearFiltering ? null : [\n    \"MANUAL_FILTERING\"\n]);\nconst divergenceShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uVelocity;\\n    void main () {\\n        float L = texture2D(uVelocity, vL).x;\\n        float R = texture2D(uVelocity, vR).x;\\n        float T = texture2D(uVelocity, vT).y;\\n        float B = texture2D(uVelocity, vB).y;\\n        vec2 C = texture2D(uVelocity, vUv).xy;\\n        if (vL.x < 0.0) { L = -C.x; }\\n        if (vR.x > 1.0) { R = -C.x; }\\n        if (vT.y > 1.0) { T = -C.y; }\\n        if (vB.y < 0.0) { B = -C.y; }\\n        float div = 0.5 * (R - L + T - B);\\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst curlShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uVelocity;\\n    void main () {\\n        float L = texture2D(uVelocity, vL).y;\\n        float R = texture2D(uVelocity, vR).y;\\n        float T = texture2D(uVelocity, vT).x;\\n        float B = texture2D(uVelocity, vB).x;\\n        float vorticity = R - L - T + B;\\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst vorticityShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision highp float;\\n    precision highp sampler2D;\\n    varying vec2 vUv;\\n    varying vec2 vL;\\n    varying vec2 vR;\\n    varying vec2 vT;\\n    varying vec2 vB;\\n    uniform sampler2D uVelocity;\\n    uniform sampler2D uCurl;\\n    uniform float curl;\\n    uniform float dt;\\n    void main () {\\n        float L = texture2D(uCurl, vL).x;\\n        float R = texture2D(uCurl, vR).x;\\n        float T = texture2D(uCurl, vT).x;\\n        float B = texture2D(uCurl, vB).x;\\n        float C = texture2D(uCurl, vUv).x;\\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n        force /= length(force) + 0.0001;\\n        force *= curl * C;\\n        force.y *= -1.0;\\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\\n        velocity += force * dt;\\n        velocity = min(max(velocity, -1000.0), 1000.0);\\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\\n    }\\n\");\nconst pressureShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uPressure;\\n    uniform sampler2D uDivergence;\\n    void main () {\\n        float L = texture2D(uPressure, vL).x;\\n        float R = texture2D(uPressure, vR).x;\\n        float T = texture2D(uPressure, vT).x;\\n        float B = texture2D(uPressure, vB).x;\\n        float C = texture2D(uPressure, vUv).x;\\n        float divergence = texture2D(uDivergence, vUv).x;\\n        float pressure = (L + R + B + T - divergence) * 0.25;\\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n    }\\n\");\nconst gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, \"\\n    precision mediump float;\\n    precision mediump sampler2D;\\n    varying highp vec2 vUv;\\n    varying highp vec2 vL;\\n    varying highp vec2 vR;\\n    varying highp vec2 vT;\\n    varying highp vec2 vB;\\n    uniform sampler2D uPressure;\\n    uniform sampler2D uVelocity;\\n    void main () {\\n        float L = texture2D(uPressure, vL).x;\\n        float R = texture2D(uPressure, vR).x;\\n        float T = texture2D(uPressure, vT).x;\\n        float B = texture2D(uPressure, vB).x;\\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\\n        velocity.xy -= vec2(R - L, T - B);\\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\\n    }\\n\");\nconst blit = (()=>{\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1,\n        -1,\n        -1,\n        1,\n        1,\n        1,\n        1,\n        -1\n    ]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n        0,\n        1,\n        2,\n        0,\n        2,\n        3\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(0);\n    return function(target) {\n        let clear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (target == null) {\n            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n            gl.viewport(0, 0, target.width, target.height);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (clear) {\n            gl.clearColor(0.0, 0.0, 0.0, 1.0);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        // CHECK_FRAMEBUFFER_STATUS();\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n})();\nfunction CHECK_FRAMEBUFFER_STATUS() {\n    let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status != gl.FRAMEBUFFER_COMPLETE) console.trace(\"Framebuffer error: \" + status);\n}\n_c = CHECK_FRAMEBUFFER_STATUS;\nlet dye;\nlet velocity;\nlet divergence;\nlet curl;\nlet pressure;\nlet bloom;\nlet bloomFramebuffers = [];\nlet sunrays;\nlet sunraysTemp;\nlet ditheringTexture = createTextureAsync(\"LDR_LLL1_0.png\");\nconst blurProgram = new Program(blurVertexShader, blurShader);\nconst copyProgram = new Program(baseVertexShader, copyShader);\nconst clearProgram = new Program(baseVertexShader, clearShader);\nconst colorProgram = new Program(baseVertexShader, colorShader);\nconst checkerboardProgram = new Program(baseVertexShader, checkerboardShader);\nconst bloomPrefilterProgram = new Program(baseVertexShader, bloomPrefilterShader);\nconst bloomBlurProgram = new Program(baseVertexShader, bloomBlurShader);\nconst bloomFinalProgram = new Program(baseVertexShader, bloomFinalShader);\nconst sunraysMaskProgram = new Program(baseVertexShader, sunraysMaskShader);\nconst sunraysProgram = new Program(baseVertexShader, sunraysShader);\nconst splatProgram = new Program(baseVertexShader, splatShader);\nconst advectionProgram = new Program(baseVertexShader, advectionShader);\nconst divergenceProgram = new Program(baseVertexShader, divergenceShader);\nconst curlProgram = new Program(baseVertexShader, curlShader);\nconst vorticityProgram = new Program(baseVertexShader, vorticityShader);\nconst pressureProgram = new Program(baseVertexShader, pressureShader);\nconst gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\nconst displayMaterial = new Material(baseVertexShader, displayShaderSource);\nfunction initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const rg = ext.formatRG;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    gl.disable(gl.BLEND);\n    if (dye == null) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n    else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n    if (velocity == null) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n    else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n    divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    initBloomFramebuffers();\n    initSunraysFramebuffers();\n}\nfunction initBloomFramebuffers() {\n    let res = getResolution(config.BLOOM_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    bloom = createFBO(res.width, res.height, rgba.internalFormat, rgba.format, texType, filtering);\n    bloomFramebuffers.length = 0;\n    for(let i = 0; i < config.BLOOM_ITERATIONS; i++){\n        let width = res.width >> i + 1;\n        let height = res.height >> i + 1;\n        if (width < 2 || height < 2) break;\n        let fbo = createFBO(width, height, rgba.internalFormat, rgba.format, texType, filtering);\n        bloomFramebuffers.push(fbo);\n    }\n}\nfunction initSunraysFramebuffers() {\n    let res = getResolution(config.SUNRAYS_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    sunrays = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);\n    sunraysTemp = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);\n}\nfunction createFBO(w, h, internalFormat, format, type, param) {\n    gl.activeTexture(gl.TEXTURE0);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    let texelSizeX = 1.0 / w;\n    let texelSizeY = 1.0 / h;\n    return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach (id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        }\n    };\n}\nfunction createDoubleFBO(w, h, internalFormat, format, type, param) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n    return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read () {\n            return fbo1;\n        },\n        set read (value){\n            fbo1 = value;\n        },\n        get write () {\n            return fbo2;\n        },\n        set write (value){\n            fbo2 = value;\n        },\n        swap () {\n            let temp = fbo1;\n            fbo1 = fbo2;\n            fbo2 = temp;\n        }\n    };\n}\nfunction resizeFBO(target, w, h, internalFormat, format, type, param) {\n    let newFBO = createFBO(w, h, internalFormat, format, type, param);\n    copyProgram.bind();\n    gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n    blit(newFBO);\n    return newFBO;\n}\nfunction resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n    if (target.width == w && target.height == h) return target;\n    target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n    target.write = createFBO(w, h, internalFormat, format, type, param);\n    target.width = w;\n    target.height = h;\n    target.texelSizeX = 1.0 / w;\n    target.texelSizeY = 1.0 / h;\n    return target;\n}\nfunction createTextureAsync(url) {\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([\n        255,\n        255,\n        255\n    ]));\n    let obj = {\n        texture,\n        width: 1,\n        height: 1,\n        attach (id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        }\n    };\n    let image = new Image();\n    image.onload = ()=>{\n        obj.width = image.width;\n        obj.height = image.height;\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n    };\n    image.src = url;\n    return obj;\n}\nfunction updateKeywords() {\n    let displayKeywords = [];\n    if (config.SHADING) displayKeywords.push(\"SHADING\");\n    if (config.BLOOM) displayKeywords.push(\"BLOOM\");\n    if (config.SUNRAYS) displayKeywords.push(\"SUNRAYS\");\n    displayMaterial.setKeywords(displayKeywords);\n}\nupdateKeywords();\ninitFramebuffers();\nmultipleSplats(parseInt(Math.random() * 20) + 5);\nlet lastUpdateTime = Date.now();\nlet colorUpdateTimer = 0.0;\nupdate();\nfunction update() {\n    const dt = calcDeltaTime();\n    if (resizeCanvas()) initFramebuffers();\n    updateColors(dt);\n    applyInputs();\n    if (!config.PAUSED) step(dt);\n    render(null);\n    requestAnimationFrame(update);\n}\nfunction calcDeltaTime() {\n    let now = Date.now();\n    let dt = (now - lastUpdateTime) / 1000;\n    dt = Math.min(dt, 0.016666);\n    lastUpdateTime = now;\n    return dt;\n}\nfunction resizeCanvas() {\n    let width = scaleByPixelRatio(canvas.clientWidth);\n    let height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\nfunction updateColors(dt) {\n    if (!config.COLORFUL) return;\n    colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n    if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach((p)=>{\n            p.color = generateColor();\n        });\n    }\n}\nfunction applyInputs() {\n    if (splatStack.length > 0) multipleSplats(splatStack.pop());\n    pointers.forEach((p)=>{\n        if (p.moved) {\n            p.moved = false;\n            splatPointer(p);\n        }\n    });\n}\nfunction step(dt) {\n    gl.disable(gl.BLEND);\n    curlProgram.bind();\n    gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n    blit(curl);\n    vorticityProgram.bind();\n    gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n    gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n    gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n    gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n    blit(velocity.write);\n    velocity.swap();\n    divergenceProgram.bind();\n    gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n    blit(divergence);\n    clearProgram.bind();\n    gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n    blit(pressure.write);\n    pressure.swap();\n    pressureProgram.bind();\n    gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n    for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        blit(pressure.write);\n        pressure.swap();\n    }\n    gradienSubtractProgram.bind();\n    gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n    gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n    blit(velocity.write);\n    velocity.swap();\n    advectionProgram.bind();\n    gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n    let velocityId = velocity.read.attach(0);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n    blit(velocity.write);\n    velocity.swap();\n    if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n    gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(dye.write);\n    dye.swap();\n}\nfunction render(target) {\n    if (config.BLOOM) applyBloom(dye.read, bloom);\n    if (config.SUNRAYS) {\n        applySunrays(dye.read, dye.write, sunrays);\n        blur(sunrays, sunraysTemp, 1);\n    }\n    if (target == null || !config.TRANSPARENT) {\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    } else {\n        gl.disable(gl.BLEND);\n    }\n    if (!config.TRANSPARENT) drawColor(target, normalizeColor(config.BACK_COLOR));\n    if (target == null && config.TRANSPARENT) drawCheckerboard(target);\n    drawDisplay(target);\n}\nfunction drawColor(target, color) {\n    colorProgram.bind();\n    gl.uniform4f(colorProgram.uniforms.color, color.r, color.g, color.b, 1);\n    blit(target);\n}\nfunction drawCheckerboard(target) {\n    checkerboardProgram.bind();\n    gl.uniform1f(checkerboardProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    blit(target);\n}\nfunction drawDisplay(target) {\n    let width = target == null ? gl.drawingBufferWidth : target.width;\n    let height = target == null ? gl.drawingBufferHeight : target.height;\n    displayMaterial.bind();\n    if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n    gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n    if (config.BLOOM) {\n        gl.uniform1i(displayMaterial.uniforms.uBloom, bloom.attach(1));\n        gl.uniform1i(displayMaterial.uniforms.uDithering, ditheringTexture.attach(2));\n        let scale = getTextureScale(ditheringTexture, width, height);\n        gl.uniform2f(displayMaterial.uniforms.ditherScale, scale.x, scale.y);\n    }\n    if (config.SUNRAYS) gl.uniform1i(displayMaterial.uniforms.uSunrays, sunrays.attach(3));\n    blit(target);\n}\nfunction applyBloom(source, destination) {\n    if (bloomFramebuffers.length < 2) return;\n    let last = destination;\n    gl.disable(gl.BLEND);\n    bloomPrefilterProgram.bind();\n    let knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;\n    let curve0 = config.BLOOM_THRESHOLD - knee;\n    let curve1 = knee * 2;\n    let curve2 = 0.25 / knee;\n    gl.uniform3f(bloomPrefilterProgram.uniforms.curve, curve0, curve1, curve2);\n    gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);\n    gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, source.attach(0));\n    blit(last);\n    bloomBlurProgram.bind();\n    for(let i = 0; i < bloomFramebuffers.length; i++){\n        let dest = bloomFramebuffers[i];\n        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n        blit(dest);\n        last = dest;\n    }\n    gl.blendFunc(gl.ONE, gl.ONE);\n    gl.enable(gl.BLEND);\n    for(let i1 = bloomFramebuffers.length - 2; i1 >= 0; i1--){\n        let baseTex = bloomFramebuffers[i1];\n        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n        gl.viewport(0, 0, baseTex.width, baseTex.height);\n        blit(baseTex);\n        last = baseTex;\n    }\n    gl.disable(gl.BLEND);\n    bloomFinalProgram.bind();\n    gl.uniform2f(bloomFinalProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n    gl.uniform1i(bloomFinalProgram.uniforms.uTexture, last.attach(0));\n    gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);\n    blit(destination);\n}\nfunction applySunrays(source, mask, destination) {\n    gl.disable(gl.BLEND);\n    sunraysMaskProgram.bind();\n    gl.uniform1i(sunraysMaskProgram.uniforms.uTexture, source.attach(0));\n    blit(mask);\n    sunraysProgram.bind();\n    gl.uniform1f(sunraysProgram.uniforms.weight, config.SUNRAYS_WEIGHT);\n    gl.uniform1i(sunraysProgram.uniforms.uTexture, mask.attach(0));\n    blit(destination);\n}\nfunction blur(target, temp, iterations) {\n    blurProgram.bind();\n    for(let i = 0; i < iterations; i++){\n        gl.uniform2f(blurProgram.uniforms.texelSize, target.texelSizeX, 0.0);\n        gl.uniform1i(blurProgram.uniforms.uTexture, target.attach(0));\n        blit(temp);\n        gl.uniform2f(blurProgram.uniforms.texelSize, 0.0, target.texelSizeY);\n        gl.uniform1i(blurProgram.uniforms.uTexture, temp.attach(0));\n        blit(target);\n    }\n}\nfunction splatPointer(pointer) {\n    let dx = pointer.deltaX * config.SPLAT_FORCE;\n    let dy = pointer.deltaY * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction multipleSplats(amount) {\n    for(let i = 0; i < amount; i++){\n        const color = generateColor();\n        color.r *= 10.0;\n        color.g *= 10.0;\n        color.b *= 10.0;\n        const x = Math.random();\n        const y = Math.random();\n        const dx = 1000 * (Math.random() - 0.5);\n        const dy = 1000 * (Math.random() - 0.5);\n        splat(x, y, dx, dy, color);\n    }\n}\nfunction splat(x, y, dx, dy, color) {\n    splatProgram.bind();\n    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x, y);\n    gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n    gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n    blit(velocity.write);\n    velocity.swap();\n    gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n    blit(dye.write);\n    dye.swap();\n}\nfunction correctRadius(radius) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) radius *= aspectRatio;\n    return radius;\n}\ncanvas.addEventListener(\"mousedown\", (e)=>{\n    let posX = scaleByPixelRatio(e.offsetX);\n    let posY = scaleByPixelRatio(e.offsetY);\n    let pointer = pointers.find((p)=>p.id == -1);\n    if (pointer == null) pointer = new pointerPrototype();\n    updatePointerDownData(pointer, -1, posX, posY);\n});\ncanvas.addEventListener(\"mousemove\", (e)=>{\n    let pointer = pointers[0];\n    if (!pointer.down) return;\n    let posX = scaleByPixelRatio(e.offsetX);\n    let posY = scaleByPixelRatio(e.offsetY);\n    updatePointerMoveData(pointer, posX, posY);\n});\nwindow.addEventListener(\"mouseup\", ()=>{\n    updatePointerUpData(pointers[0]);\n});\ncanvas.addEventListener(\"touchstart\", (e)=>{\n    e.preventDefault();\n    const touches = e.targetTouches;\n    while(touches.length >= pointers.length)pointers.push(new pointerPrototype());\n    for(let i = 0; i < touches.length; i++){\n        let posX = scaleByPixelRatio(touches[i].pageX);\n        let posY = scaleByPixelRatio(touches[i].pageY);\n        updatePointerDownData(pointers[i + 1], touches[i].identifier, posX, posY);\n    }\n});\ncanvas.addEventListener(\"touchmove\", (e)=>{\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for(let i = 0; i < touches.length; i++){\n        let pointer = pointers[i + 1];\n        if (!pointer.down) continue;\n        let posX = scaleByPixelRatio(touches[i].pageX);\n        let posY = scaleByPixelRatio(touches[i].pageY);\n        updatePointerMoveData(pointer, posX, posY);\n    }\n}, false);\nwindow.addEventListener(\"touchend\", (e)=>{\n    const touches = e.changedTouches;\n    for(let i = 0; i < touches.length; i++){\n        let pointer = pointers.find((p)=>p.id == touches[i].identifier);\n        if (pointer == null) continue;\n        updatePointerUpData(pointer);\n    }\n});\nwindow.addEventListener(\"keydown\", (e)=>{\n    if (e.code === \"KeyP\") config.PAUSED = !config.PAUSED;\n    if (e.key === \" \") splatStack.push(parseInt(Math.random() * 20) + 5);\n});\nfunction updatePointerDownData(pointer, id, posX, posY) {\n    pointer.id = id;\n    pointer.down = true;\n    pointer.moved = false;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.deltaX = 0;\n    pointer.deltaY = 0;\n    pointer.color = generateColor();\n}\nfunction updatePointerMoveData(pointer, posX, posY) {\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n    pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction updatePointerUpData(pointer) {\n    pointer.down = false;\n}\nfunction correctDeltaX(delta) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1) delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1) delta /= aspectRatio;\n    return delta;\n}\nfunction generateColor() {\n    let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.15;\n    c.g *= 0.15;\n    c.b *= 0.15;\n    return c;\n}\nfunction HSVtoRGB(h, s, v) {\n    let r, g, b, i, f, p, q, t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch(i % 6){\n        case 0:\n            r = v, g = t, b = p;\n            break;\n        case 1:\n            r = q, g = v, b = p;\n            break;\n        case 2:\n            r = p, g = v, b = t;\n            break;\n        case 3:\n            r = p, g = q, b = v;\n            break;\n        case 4:\n            r = t, g = p, b = v;\n            break;\n        case 5:\n            r = v, g = p, b = q;\n            break;\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\n_c1 = HSVtoRGB;\nfunction normalizeColor(input) {\n    let output = {\n        r: input.r / 255,\n        g: input.g / 255,\n        b: input.b / 255\n    };\n    return output;\n}\nfunction wrap(value1, min, max) {\n    let range = max - min;\n    if (range == 0) return min;\n    return (value1 - min) % range + min;\n}\nfunction getResolution(resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n    let min = Math.round(resolution);\n    let max = Math.round(resolution * aspectRatio);\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n        width: max,\n        height: min\n    };\n    else return {\n        width: min,\n        height: max\n    };\n}\nfunction getTextureScale(texture, width, height) {\n    return {\n        x: width / texture.width,\n        y: height / texture.height\n    };\n}\nfunction scaleByPixelRatio(input) {\n    let pixelRatio = window.devicePixelRatio || 1;\n    return Math.floor(input * pixelRatio);\n}\nfunction hashCode(s) {\n    if (s.length == 0) return 0;\n    let hash = 0;\n    for(let i = 0; i < s.length; i++){\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\nvar _c, _c1;\n$RefreshReg$(_c, \"CHECK_FRAMEBUFFER_STATUS\");\n$RefreshReg$(_c1, \"HSVtoRGB\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0EsY0FBYyxNQUFNQTtJQUV6QyxJQUFJNU4sTUFBTUQsS0FBS2dTLEtBQUssQ0FBQ0Q7SUFDckIsSUFBSTdSLE1BQU1GLEtBQUtnUyxLQUFLLENBQUNELGFBQWFsRTtJQUVsQyxJQUFJbFQsR0FBR3FMLGtCQUFrQixHQUFHckwsR0FBR3NMLG1CQUFtQixFQUNoRCxPQUFPO1FBQUV4SCxPQUFPeUI7UUFBS3hCLFFBQVF1QjtJQUFJO1NBQzlCLE9BQU87UUFBRXhCLE9BQU93QjtRQUFLdkIsUUFBUXdCO0lBQUk7QUFDeEM7QUFFQSxTQUFTK04sZ0JBQWdCclIsT0FBTyxFQUFFNkIsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDL0MsT0FBTztRQUNMeVAsR0FBRzFQLFFBQVE3QixRQUFRNkIsS0FBSztRQUN4QjJQLEdBQUcxUCxTQUFTOUIsUUFBUThCLE1BQU07SUFDNUI7QUFDRjtBQUVBLFNBQVNvTixrQkFBa0IvTCxLQUFLLEVBQUU7SUFDaEMsSUFBSWtTLGFBQWFyYSxPQUFPc2EsZ0JBQWdCLElBQUk7SUFDNUMsT0FBT2xTLEtBQUs0UixLQUFLLENBQUM3UixRQUFRa1M7QUFDNUI7QUFFQSxTQUFTMVEsU0FBU2dRLENBQUMsRUFBRTtJQUNuQixJQUFJQSxFQUFFbFMsTUFBTSxJQUFJLEdBQUcsT0FBTztJQUMxQixJQUFJaUMsT0FBTztJQUNYLElBQUssSUFBSTNCLElBQUksR0FBR0EsSUFBSTRSLEVBQUVsUyxNQUFNLEVBQUVNLElBQUs7UUFDakMyQixPQUFPLENBQUNBLFFBQVEsS0FBS0EsT0FBT2lRLEVBQUVZLFVBQVUsQ0FBQ3hTO1FBQ3pDMkIsUUFBUSxHQUFHLDJCQUEyQjtJQUN4QztJQUNBLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2hhcmVkL2xpYi93ZWJnbC5qcz8zZDBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5NSVQgTGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFBhdmVsIERvYnJ5YWtvdlxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNpbXVsYXRpb24gc2VjdGlvblxubGV0IGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Ntb2tlLXdlYmdsJyk7XG5yZXNpemVDYW52YXMoKTtcblxubGV0IGNvbmZpZyA9IHtcbiAgU0lNX1JFU09MVVRJT046IDEyOCxcbiAgRFlFX1JFU09MVVRJT046IDEwMjQsXG4gIENBUFRVUkVfUkVTT0xVVElPTjogNTEyLFxuICBERU5TSVRZX0RJU1NJUEFUSU9OOiAxLFxuICBWRUxPQ0lUWV9ESVNTSVBBVElPTjogMC4yLFxuICBQUkVTU1VSRTogMC44LFxuICBQUkVTU1VSRV9JVEVSQVRJT05TOiAyMCxcbiAgQ1VSTDogMzAsXG4gIFNQTEFUX1JBRElVUzogMC4yNSxcbiAgU1BMQVRfRk9SQ0U6IDYwMDAsXG4gIFNIQURJTkc6IHRydWUsXG4gIENPTE9SRlVMOiB0cnVlLFxuICBDT0xPUl9VUERBVEVfU1BFRUQ6IDEwLFxuICBQQVVTRUQ6IGZhbHNlLFxuICBCQUNLX0NPTE9SOiB7IHI6IDAsIGc6IDAsIGI6IDAgfSxcbiAgVFJBTlNQQVJFTlQ6IGZhbHNlLFxuICBCTE9PTTogdHJ1ZSxcbiAgQkxPT01fSVRFUkFUSU9OUzogOCxcbiAgQkxPT01fUkVTT0xVVElPTjogMjU2LFxuICBCTE9PTV9JTlRFTlNJVFk6IDAuOCxcbiAgQkxPT01fVEhSRVNIT0xEOiAwLjYsXG4gIEJMT09NX1NPRlRfS05FRTogMC43LFxuICBTVU5SQVlTOiB0cnVlLFxuICBTVU5SQVlTX1JFU09MVVRJT046IDE5NixcbiAgU1VOUkFZU19XRUlHSFQ6IDEuMCxcbn07XG5cbmZ1bmN0aW9uIHBvaW50ZXJQcm90b3R5cGUoKSB7XG4gIHRoaXMuaWQgPSAtMTtcbiAgdGhpcy50ZXhjb29yZFggPSAwO1xuICB0aGlzLnRleGNvb3JkWSA9IDA7XG4gIHRoaXMucHJldlRleGNvb3JkWCA9IDA7XG4gIHRoaXMucHJldlRleGNvb3JkWSA9IDA7XG4gIHRoaXMuZGVsdGFYID0gMDtcbiAgdGhpcy5kZWx0YVkgPSAwO1xuICB0aGlzLmRvd24gPSBmYWxzZTtcbiAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICB0aGlzLmNvbG9yID0gWzMwLCAwLCAzMDBdO1xufVxuXG5sZXQgcG9pbnRlcnMgPSBbXTtcbmxldCBzcGxhdFN0YWNrID0gW107XG5wb2ludGVycy5wdXNoKG5ldyBwb2ludGVyUHJvdG90eXBlKCkpO1xuXG5jb25zdCB7IGdsLCBleHQgfSA9IGdldFdlYkdMQ29udGV4dChjYW52YXMpO1xuXG5pZiAoaXNNb2JpbGUoKSkge1xuICBjb25maWcuRFlFX1JFU09MVVRJT04gPSA1MTI7XG59XG5pZiAoIWV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nKSB7XG4gIGNvbmZpZy5EWUVfUkVTT0xVVElPTiA9IDUxMjtcbiAgY29uZmlnLlNIQURJTkcgPSBmYWxzZTtcbiAgY29uZmlnLkJMT09NID0gZmFsc2U7XG4gIGNvbmZpZy5TVU5SQVlTID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXMpIHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIGFscGhhOiB0cnVlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gIH07XG5cbiAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHBhcmFtcyk7XG4gIGNvbnN0IGlzV2ViR0wyID0gISFnbDtcbiAgaWYgKCFpc1dlYkdMMilcbiAgICBnbCA9XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBwYXJhbXMpIHx8XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgcGFyYW1zKTtcblxuICBsZXQgaGFsZkZsb2F0O1xuICBsZXQgc3VwcG9ydExpbmVhckZpbHRlcmluZztcbiAgaWYgKGlzV2ViR0wyKSB7XG4gICAgZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyk7XG4gIH0gZWxzZSB7XG4gICAgaGFsZkZsb2F0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG4gICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKTtcbiAgfVxuXG4gIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTtcblxuICBjb25zdCBoYWxmRmxvYXRUZXhUeXBlID0gaXNXZWJHTDIgPyBnbC5IQUxGX0ZMT0FUIDogaGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTO1xuICBsZXQgZm9ybWF0UkdCQTtcbiAgbGV0IGZvcm1hdFJHO1xuICBsZXQgZm9ybWF0UjtcblxuICBpZiAoaXNXZWJHTDIpIHtcbiAgICBmb3JtYXRSR0JBID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBMTZGLCBnbC5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICBmb3JtYXRSRyA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkcxNkYsIGdsLlJHLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICBmb3JtYXRSID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SMTZGLCBnbC5SRUQsIGhhbGZGbG9hdFRleFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGZvcm1hdFJHQkEgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpO1xuICAgIGZvcm1hdFJHID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBLCBnbC5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICBmb3JtYXRSID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBLCBnbC5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2wsXG4gICAgZXh0OiB7XG4gICAgICBmb3JtYXRSR0JBLFxuICAgICAgZm9ybWF0UkcsXG4gICAgICBmb3JtYXRSLFxuICAgICAgaGFsZkZsb2F0VGV4VHlwZSxcbiAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlKSB7XG4gIGlmICghc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoZ2wsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUpKSB7XG4gICAgc3dpdGNoIChpbnRlcm5hbEZvcm1hdCkge1xuICAgICAgY2FzZSBnbC5SMTZGOlxuICAgICAgICByZXR1cm4gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SRzE2RiwgZ2wuUkcsIHR5cGUpO1xuICAgICAgY2FzZSBnbC5SRzE2RjpcbiAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQTE2RiwgZ2wuUkdCQSwgdHlwZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGludGVybmFsRm9ybWF0LFxuICAgIGZvcm1hdCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoZ2wsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUpIHtcbiAgbGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCA0LCA0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuXG4gIGxldCBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgdGV4dHVyZSxcbiAgICAwXG4gICk7XG5cbiAgbGV0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICByZXR1cm4gc3RhdHVzID09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFO1xufVxuXG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuIC9Nb2JpfEFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlU2NyZWVuc2hvdCgpIHtcbiAgbGV0IHJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLkNBUFRVUkVfUkVTT0xVVElPTik7XG4gIGxldCB0YXJnZXQgPSBjcmVhdGVGQk8oXG4gICAgcmVzLndpZHRoLFxuICAgIHJlcy5oZWlnaHQsXG4gICAgZXh0LmZvcm1hdFJHQkEuaW50ZXJuYWxGb3JtYXQsXG4gICAgZXh0LmZvcm1hdFJHQkEuZm9ybWF0LFxuICAgIGV4dC5oYWxmRmxvYXRUZXhUeXBlLFxuICAgIGdsLk5FQVJFU1RcbiAgKTtcbiAgcmVuZGVyKHRhcmdldCk7XG5cbiAgbGV0IHRleHR1cmUgPSBmcmFtZWJ1ZmZlclRvVGV4dHVyZSh0YXJnZXQpO1xuICB0ZXh0dXJlID0gbm9ybWFsaXplVGV4dHVyZSh0ZXh0dXJlLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuXG4gIGxldCBjYXB0dXJlQ2FudmFzID0gdGV4dHVyZVRvQ2FudmFzKHRleHR1cmUsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gIGxldCBkYXRhdXJpID0gY2FwdHVyZUNhbnZhcy50b0RhdGFVUkwoKTtcbiAgZG93bmxvYWRVUkkoJ2ZsdWlkLnBuZycsIGRhdGF1cmkpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKGRhdGF1cmkpO1xufVxuXG5mdW5jdGlvbiBmcmFtZWJ1ZmZlclRvVGV4dHVyZSh0YXJnZXQpIHtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0YXJnZXQuZmJvKTtcbiAgbGV0IGxlbmd0aCA9IHRhcmdldC53aWR0aCAqIHRhcmdldC5oZWlnaHQgKiA0O1xuICBsZXQgdGV4dHVyZSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgZ2wucmVhZFBpeGVscygwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQsIGdsLlJHQkEsIGdsLkZMT0FULCB0ZXh0dXJlKTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRleHR1cmUodGV4dHVyZSwgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZS5sZW5ndGgpO1xuICBsZXQgaWQgPSAwO1xuICBmb3IgKGxldCBpID0gaGVpZ2h0IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIGxldCBuaWQgPSBpICogd2lkdGggKiA0ICsgaiAqIDQ7XG4gICAgICByZXN1bHRbbmlkICsgMF0gPSBjbGFtcDAxKHRleHR1cmVbaWQgKyAwXSkgKiAyNTU7XG4gICAgICByZXN1bHRbbmlkICsgMV0gPSBjbGFtcDAxKHRleHR1cmVbaWQgKyAxXSkgKiAyNTU7XG4gICAgICByZXN1bHRbbmlkICsgMl0gPSBjbGFtcDAxKHRleHR1cmVbaWQgKyAyXSkgKiAyNTU7XG4gICAgICByZXN1bHRbbmlkICsgM10gPSBjbGFtcDAxKHRleHR1cmVbaWQgKyAzXSkgKiAyNTU7XG4gICAgICBpZCArPSA0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjbGFtcDAxKGlucHV0KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChpbnB1dCwgMCksIDEpO1xufVxuXG5mdW5jdGlvbiB0ZXh0dXJlVG9DYW52YXModGV4dHVyZSwgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgY2FwdHVyZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBsZXQgY3R4ID0gY2FwdHVyZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjYXB0dXJlQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhcHR1cmVDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGxldCBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICBpbWFnZURhdGEuZGF0YS5zZXQodGV4dHVyZSk7XG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICByZXR1cm4gY2FwdHVyZUNhbnZhcztcbn1cblxuZnVuY3Rpb24gZG93bmxvYWRVUkkoZmlsZW5hbWUsIHVyaSkge1xuICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgbGluay5kb3dubG9hZCA9IGZpbGVuYW1lO1xuICBsaW5rLmhyZWYgPSB1cmk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gIGxpbmsuY2xpY2soKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbn1cblxuY2xhc3MgTWF0ZXJpYWwge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGZyYWdtZW50U2hhZGVyU291cmNlO1xuICAgIHRoaXMucHJvZ3JhbXMgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZVByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybXMgPSBbXTtcbiAgfVxuXG4gIHNldEtleXdvcmRzKGtleXdvcmRzKSB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5d29yZHMubGVuZ3RoOyBpKyspIGhhc2ggKz0gaGFzaENvZGUoa2V5d29yZHNbaV0pO1xuXG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLnByb2dyYW1zW2hhc2hdO1xuICAgIGlmIChwcm9ncmFtID09IG51bGwpIHtcbiAgICAgIGxldCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSxcbiAgICAgICAga2V5d29yZHNcbiAgICAgICk7XG4gICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgdGhpcy5wcm9ncmFtc1toYXNoXSA9IHByb2dyYW07XG4gICAgfVxuXG4gICAgaWYgKHByb2dyYW0gPT0gdGhpcy5hY3RpdmVQcm9ncmFtKSByZXR1cm47XG5cbiAgICB0aGlzLnVuaWZvcm1zID0gZ2V0VW5pZm9ybXMocHJvZ3JhbSk7XG4gICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gcHJvZ3JhbTtcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLmFjdGl2ZVByb2dyYW0pO1xuICB9XG59XG5cbmNsYXNzIFByb2dyYW0ge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgIHRoaXMucHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHRoaXMucHJvZ3JhbSk7XG4gIH1cblxuICBiaW5kKCkge1xuICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgbGV0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKVxuICAgIGNvbnNvbGUudHJhY2UoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuXG4gIHJldHVybiBwcm9ncmFtO1xufVxuXG5mdW5jdGlvbiBnZXRVbmlmb3Jtcyhwcm9ncmFtKSB7XG4gIGxldCB1bmlmb3JtcyA9IFtdO1xuICBsZXQgdW5pZm9ybUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XG4gICAgbGV0IHVuaWZvcm1OYW1lID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKS5uYW1lO1xuICAgIHVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKHR5cGUsIHNvdXJjZSwga2V5d29yZHMpIHtcbiAgc291cmNlID0gYWRkS2V5d29yZHMoc291cmNlLCBrZXl3b3Jkcyk7XG5cbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpXG4gICAgY29uc29sZS50cmFjZShnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuXG4gIHJldHVybiBzaGFkZXI7XG59XG5cbmZ1bmN0aW9uIGFkZEtleXdvcmRzKHNvdXJjZSwga2V5d29yZHMpIHtcbiAgaWYgKGtleXdvcmRzID09IG51bGwpIHJldHVybiBzb3VyY2U7XG4gIGxldCBrZXl3b3Jkc1N0cmluZyA9ICcnO1xuICBrZXl3b3Jkcy5mb3JFYWNoKChrZXl3b3JkKSA9PiB7XG4gICAga2V5d29yZHNTdHJpbmcgKz0gJyNkZWZpbmUgJyArIGtleXdvcmQgKyAnXFxuJztcbiAgfSk7XG4gIHJldHVybiBrZXl3b3Jkc1N0cmluZyArIHNvdXJjZTtcbn1cblxuY29uc3QgYmFzZVZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLlZFUlRFWF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdlV2ID0gYVBvc2l0aW9uICogMC41ICsgMC41O1xuICAgICAgICB2TCA9IHZVdiAtIHZlYzIodGV4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgIHZSID0gdlV2ICsgdmVjMih0ZXhlbFNpemUueCwgMC4wKTtcbiAgICAgICAgdlQgPSB2VXYgKyB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICB2QiA9IHZVdiAtIHZlYzIoMC4wLCB0ZXhlbFNpemUueSk7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBibHVyVmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuVkVSVEVYX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdlV2ID0gYVBvc2l0aW9uICogMC41ICsgMC41O1xuICAgICAgICBmbG9hdCBvZmZzZXQgPSAxLjMzMzMzMzMzO1xuICAgICAgICB2TCA9IHZVdiAtIHRleGVsU2l6ZSAqIG9mZnNldDtcbiAgICAgICAgdlIgPSB2VXYgKyB0ZXhlbFNpemUgKiBvZmZzZXQ7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBibHVyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KSAqIDAuMjk0MTE3NjQ7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZMKSAqIDAuMzUyOTQxMTc7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKSAqIDAuMzUyOTQxMTc7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHN1bTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBjb3B5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGNsZWFyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCB2YWx1ZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2YWx1ZSAqIHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBjb2xvclNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHVuaWZvcm0gdmVjNCBjb2xvcjtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBjaGVja2VyYm9hcmRTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgI2RlZmluZSBTQ0FMRSAyNS4wXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMiB1diA9IGZsb29yKHZVdiAqIFNDQUxFICogdmVjMihhc3BlY3RSYXRpbywgMS4wKSk7XG4gICAgICAgIGZsb2F0IHYgPSBtb2QodXYueCArIHV2LnksIDIuMCk7XG4gICAgICAgIHYgPSB2ICogMC4xICsgMC44O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzModiksIDEuMCk7XG4gICAgfVxuYFxuKTtcblxuY29uc3QgZGlzcGxheVNoYWRlclNvdXJjZSA9IGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1Qmxvb207XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVN1bnJheXM7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdURpdGhlcmluZztcbiAgICB1bmlmb3JtIHZlYzIgZGl0aGVyU2NhbGU7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICB2ZWMzIGxpbmVhclRvR2FtbWEgKHZlYzMgY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSBtYXgoY29sb3IsIHZlYzMoMCkpO1xuICAgICAgICByZXR1cm4gbWF4KDEuMDU1ICogcG93KGNvbG9yLCB2ZWMzKDAuNDE2NjY2NjY3KSkgLSAwLjA1NSwgdmVjMygwKSk7XG4gICAgfVxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzMgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS5yZ2I7XG4gICAgI2lmZGVmIFNIQURJTkdcbiAgICAgICAgdmVjMyBsYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpLnJnYjtcbiAgICAgICAgdmVjMyByYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlIpLnJnYjtcbiAgICAgICAgdmVjMyB0YyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpLnJnYjtcbiAgICAgICAgdmVjMyBiYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpLnJnYjtcbiAgICAgICAgZmxvYXQgZHggPSBsZW5ndGgocmMpIC0gbGVuZ3RoKGxjKTtcbiAgICAgICAgZmxvYXQgZHkgPSBsZW5ndGgodGMpIC0gbGVuZ3RoKGJjKTtcbiAgICAgICAgdmVjMyBuID0gbm9ybWFsaXplKHZlYzMoZHgsIGR5LCBsZW5ndGgodGV4ZWxTaXplKSkpO1xuICAgICAgICB2ZWMzIGwgPSB2ZWMzKDAuMCwgMC4wLCAxLjApO1xuICAgICAgICBmbG9hdCBkaWZmdXNlID0gY2xhbXAoZG90KG4sIGwpICsgMC43LCAwLjcsIDEuMCk7XG4gICAgICAgIGMgKj0gZGlmZnVzZTtcbiAgICAjZW5kaWZcbiAgICAjaWZkZWYgQkxPT01cbiAgICAgICAgdmVjMyBibG9vbSA9IHRleHR1cmUyRCh1Qmxvb20sIHZVdikucmdiO1xuICAgICNlbmRpZlxuICAgICNpZmRlZiBTVU5SQVlTXG4gICAgICAgIGZsb2F0IHN1bnJheXMgPSB0ZXh0dXJlMkQodVN1bnJheXMsIHZVdikucjtcbiAgICAgICAgYyAqPSBzdW5yYXlzO1xuICAgICNpZmRlZiBCTE9PTVxuICAgICAgICBibG9vbSAqPSBzdW5yYXlzO1xuICAgICNlbmRpZlxuICAgICNlbmRpZlxuICAgICNpZmRlZiBCTE9PTVxuICAgICAgICBmbG9hdCBub2lzZSA9IHRleHR1cmUyRCh1RGl0aGVyaW5nLCB2VXYgKiBkaXRoZXJTY2FsZSkucjtcbiAgICAgICAgbm9pc2UgPSBub2lzZSAqIDIuMCAtIDEuMDtcbiAgICAgICAgYmxvb20gKz0gbm9pc2UgLyAyNTUuMDtcbiAgICAgICAgYmxvb20gPSBsaW5lYXJUb0dhbW1hKGJsb29tKTtcbiAgICAgICAgYyArPSBibG9vbTtcbiAgICAjZW5kaWZcbiAgICAgICAgZmxvYXQgYSA9IG1heChjLnIsIG1heChjLmcsIGMuYikpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMsIGEpO1xuICAgIH1cbmA7XG5cbmNvbnN0IGJsb29tUHJlZmlsdGVyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSB2ZWMzIGN1cnZlO1xuICAgIHVuaWZvcm0gZmxvYXQgdGhyZXNob2xkO1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzMgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS5yZ2I7XG4gICAgICAgIGZsb2F0IGJyID0gbWF4KGMuciwgbWF4KGMuZywgYy5iKSk7XG4gICAgICAgIGZsb2F0IHJxID0gY2xhbXAoYnIgLSBjdXJ2ZS54LCAwLjAsIGN1cnZlLnkpO1xuICAgICAgICBycSA9IGN1cnZlLnogKiBycSAqIHJxO1xuICAgICAgICBjICo9IG1heChycSwgYnIgLSB0aHJlc2hvbGQpIC8gbWF4KGJyLCAwLjAwMDEpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMsIDAuMCk7XG4gICAgfVxuYFxuKTtcblxuY29uc3QgYmxvb21CbHVyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Uik7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpO1xuICAgICAgICBzdW0gKj0gMC4yNTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGJsb29tRmluYWxTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLjApO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCk7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Qik7XG4gICAgICAgIHN1bSAqPSAwLjI1O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBzdW0gKiBpbnRlbnNpdHk7XG4gICAgfVxuYFxuKTtcblxuY29uc3Qgc3VucmF5c01hc2tTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICAgICAgZmxvYXQgYnIgPSBtYXgoYy5yLCBtYXgoYy5nLCBjLmIpKTtcbiAgICAgICAgYy5hID0gMS4wIC0gbWluKG1heChiciAqIDIwLjAsIDAuMCksIDAuOCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XG4gICAgfVxuYFxuKTtcblxuY29uc3Qgc3VucmF5c1NoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCB3ZWlnaHQ7XG4gICAgI2RlZmluZSBJVEVSQVRJT05TIDE2XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgRGVuc2l0eSA9IDAuMztcbiAgICAgICAgZmxvYXQgRGVjYXkgPSAwLjk1O1xuICAgICAgICBmbG9hdCBFeHBvc3VyZSA9IDAuNztcbiAgICAgICAgdmVjMiBjb29yZCA9IHZVdjtcbiAgICAgICAgdmVjMiBkaXIgPSB2VXYgLSAwLjU7XG4gICAgICAgIGRpciAqPSAxLjAgLyBmbG9hdChJVEVSQVRJT05TKSAqIERlbnNpdHk7XG4gICAgICAgIGZsb2F0IGlsbHVtaW5hdGlvbkRlY2F5ID0gMS4wO1xuICAgICAgICBmbG9hdCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS5hO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IElURVJBVElPTlM7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29vcmQgLT0gZGlyO1xuICAgICAgICAgICAgZmxvYXQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBjb29yZCkuYTtcbiAgICAgICAgICAgIGNvbG9yICs9IGNvbCAqIGlsbHVtaW5hdGlvbkRlY2F5ICogd2VpZ2h0O1xuICAgICAgICAgICAgaWxsdW1pbmF0aW9uRGVjYXkgKj0gRGVjYXk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciAqIEV4cG9zdXJlLCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBzcGxhdFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRhcmdldDtcbiAgICB1bmlmb3JtIGZsb2F0IGFzcGVjdFJhdGlvO1xuICAgIHVuaWZvcm0gdmVjMyBjb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcG9pbnQ7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMiBwID0gdlV2IC0gcG9pbnQueHk7XG4gICAgICAgIHAueCAqPSBhc3BlY3RSYXRpbztcbiAgICAgICAgdmVjMyBzcGxhdCA9IGV4cCgtZG90KHAsIHApIC8gcmFkaXVzKSAqIGNvbG9yO1xuICAgICAgICB2ZWMzIGJhc2UgPSB0ZXh0dXJlMkQodVRhcmdldCwgdlV2KS54eXo7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYmFzZSArIHNwbGF0LCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGFkdmVjdGlvblNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTb3VyY2U7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcbiAgICB1bmlmb3JtIHZlYzIgZHllVGV4ZWxTaXplO1xuICAgIHVuaWZvcm0gZmxvYXQgZHQ7XG4gICAgdW5pZm9ybSBmbG9hdCBkaXNzaXBhdGlvbjtcbiAgICB2ZWM0IGJpbGVycCAoc2FtcGxlcjJEIHNhbSwgdmVjMiB1diwgdmVjMiB0c2l6ZSkge1xuICAgICAgICB2ZWMyIHN0ID0gdXYgLyB0c2l6ZSAtIDAuNTtcbiAgICAgICAgdmVjMiBpdXYgPSBmbG9vcihzdCk7XG4gICAgICAgIHZlYzIgZnV2ID0gZnJhY3Qoc3QpO1xuICAgICAgICB2ZWM0IGEgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigwLjUsIDAuNSkpICogdHNpemUpO1xuICAgICAgICB2ZWM0IGIgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigxLjUsIDAuNSkpICogdHNpemUpO1xuICAgICAgICB2ZWM0IGMgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigwLjUsIDEuNSkpICogdHNpemUpO1xuICAgICAgICB2ZWM0IGQgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigxLjUsIDEuNSkpICogdHNpemUpO1xuICAgICAgICByZXR1cm4gbWl4KG1peChhLCBiLCBmdXYueCksIG1peChjLCBkLCBmdXYueCksIGZ1di55KTtcbiAgICB9XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAjaWZkZWYgTUFOVUFMX0ZJTFRFUklOR1xuICAgICAgICB2ZWMyIGNvb3JkID0gdlV2IC0gZHQgKiBiaWxlcnAodVZlbG9jaXR5LCB2VXYsIHRleGVsU2l6ZSkueHkgKiB0ZXhlbFNpemU7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gYmlsZXJwKHVTb3VyY2UsIGNvb3JkLCBkeWVUZXhlbFNpemUpO1xuICAgICNlbHNlXG4gICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHkgKiB0ZXhlbFNpemU7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdGV4dHVyZTJEKHVTb3VyY2UsIGNvb3JkKTtcbiAgICAjZW5kaWZcbiAgICAgICAgZmxvYXQgZGVjYXkgPSAxLjAgKyBkaXNzaXBhdGlvbiAqIGR0O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSByZXN1bHQgLyBkZWNheTtcbiAgICB9YCxcbiAgZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBudWxsIDogWydNQU5VQUxfRklMVEVSSU5HJ11cbik7XG5cbmNvbnN0IGRpdmVyZ2VuY2VTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueDtcbiAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZSKS54O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlQpLnk7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueTtcbiAgICAgICAgdmVjMiBDID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgaWYgKHZMLnggPCAwLjApIHsgTCA9IC1DLng7IH1cbiAgICAgICAgaWYgKHZSLnggPiAxLjApIHsgUiA9IC1DLng7IH1cbiAgICAgICAgaWYgKHZULnkgPiAxLjApIHsgVCA9IC1DLnk7IH1cbiAgICAgICAgaWYgKHZCLnkgPCAwLjApIHsgQiA9IC1DLnk7IH1cbiAgICAgICAgZmxvYXQgZGl2ID0gMC41ICogKFIgLSBMICsgVCAtIEIpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRpdiwgMC4wLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuKTtcblxuY29uc3QgY3VybFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS55O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlIpLnk7XG4gICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueDtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS54O1xuICAgICAgICBmbG9hdCB2b3J0aWNpdHkgPSBSIC0gTCAtIFQgKyBCO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNSAqIHZvcnRpY2l0eSwgMC4wLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuKTtcblxuY29uc3Qgdm9ydGljaXR5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVDdXJsO1xuICAgIHVuaWZvcm0gZmxvYXQgY3VybDtcbiAgICB1bmlmb3JtIGZsb2F0IGR0O1xuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodUN1cmwsIHZMKS54O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVDdXJsLCB2UikueDtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1Q3VybCwgdlQpLng7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodUN1cmwsIHZCKS54O1xuICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVDdXJsLCB2VXYpLng7XG4gICAgICAgIHZlYzIgZm9yY2UgPSAwLjUgKiB2ZWMyKGFicyhUKSAtIGFicyhCKSwgYWJzKFIpIC0gYWJzKEwpKTtcbiAgICAgICAgZm9yY2UgLz0gbGVuZ3RoKGZvcmNlKSArIDAuMDAwMTtcbiAgICAgICAgZm9yY2UgKj0gY3VybCAqIEM7XG4gICAgICAgIGZvcmNlLnkgKj0gLTEuMDtcbiAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgIHZlbG9jaXR5ICs9IGZvcmNlICogZHQ7XG4gICAgICAgIHZlbG9jaXR5ID0gbWluKG1heCh2ZWxvY2l0eSwgLTEwMDAuMCksIDEwMDAuMCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBwcmVzc3VyZVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1UHJlc3N1cmU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdURpdmVyZ2VuY2U7XG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlIpLng7XG4gICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2VCkueDtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlV2KS54O1xuICAgICAgICBmbG9hdCBkaXZlcmdlbmNlID0gdGV4dHVyZTJEKHVEaXZlcmdlbmNlLCB2VXYpLng7XG4gICAgICAgIGZsb2F0IHByZXNzdXJlID0gKEwgKyBSICsgQiArIFQgLSBkaXZlcmdlbmNlKSAqIDAuMjU7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocHJlc3N1cmUsIDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbmBcbik7XG5cbmNvbnN0IGdyYWRpZW50U3VidHJhY3RTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2UikueDtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgIHZlYzIgdmVsb2NpdHkgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICB2ZWxvY2l0eS54eSAtPSB2ZWMyKFIgLSBMLCBUIC0gQik7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pO1xuXG5jb25zdCBibGl0ID0gKCgpID0+IHtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgZ2wuYnVmZmVyRGF0YShcbiAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAtMSwgMSwgMSwgMSwgMSwgLTFdKSxcbiAgICBnbC5TVEFUSUNfRFJBV1xuICApO1xuICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSk7XG4gIGdsLmJ1ZmZlckRhdGEoXG4gICAgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSksXG4gICAgZ2wuU1RBVElDX0RSQVdcbiAgKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcigwLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKTtcblxuICByZXR1cm4gKHRhcmdldCwgY2xlYXIgPSBmYWxzZSkgPT4ge1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRhcmdldC5mYm8pO1xuICAgIH1cbiAgICBpZiAoY2xlYXIpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIH1cbiAgICAvLyBDSEVDS19GUkFNRUJVRkZFUl9TVEFUVVMoKTtcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiBDSEVDS19GUkFNRUJVRkZFUl9TVEFUVVMoKSB7XG4gIGxldCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgaWYgKHN0YXR1cyAhPSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSlcbiAgICBjb25zb2xlLnRyYWNlKCdGcmFtZWJ1ZmZlciBlcnJvcjogJyArIHN0YXR1cyk7XG59XG5cbmxldCBkeWU7XG5sZXQgdmVsb2NpdHk7XG5sZXQgZGl2ZXJnZW5jZTtcbmxldCBjdXJsO1xubGV0IHByZXNzdXJlO1xubGV0IGJsb29tO1xubGV0IGJsb29tRnJhbWVidWZmZXJzID0gW107XG5sZXQgc3VucmF5cztcbmxldCBzdW5yYXlzVGVtcDtcblxubGV0IGRpdGhlcmluZ1RleHR1cmUgPSBjcmVhdGVUZXh0dXJlQXN5bmMoJ0xEUl9MTEwxXzAucG5nJyk7XG5cbmNvbnN0IGJsdXJQcm9ncmFtID0gbmV3IFByb2dyYW0oYmx1clZlcnRleFNoYWRlciwgYmx1clNoYWRlcik7XG5jb25zdCBjb3B5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNvcHlTaGFkZXIpO1xuY29uc3QgY2xlYXJQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY2xlYXJTaGFkZXIpO1xuY29uc3QgY29sb3JQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY29sb3JTaGFkZXIpO1xuY29uc3QgY2hlY2tlcmJvYXJkUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNoZWNrZXJib2FyZFNoYWRlcik7XG5jb25zdCBibG9vbVByZWZpbHRlclByb2dyYW0gPSBuZXcgUHJvZ3JhbShcbiAgYmFzZVZlcnRleFNoYWRlcixcbiAgYmxvb21QcmVmaWx0ZXJTaGFkZXJcbik7XG5jb25zdCBibG9vbUJsdXJQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYmxvb21CbHVyU2hhZGVyKTtcbmNvbnN0IGJsb29tRmluYWxQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYmxvb21GaW5hbFNoYWRlcik7XG5jb25zdCBzdW5yYXlzTWFza1Byb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBzdW5yYXlzTWFza1NoYWRlcik7XG5jb25zdCBzdW5yYXlzUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHN1bnJheXNTaGFkZXIpO1xuY29uc3Qgc3BsYXRQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgc3BsYXRTaGFkZXIpO1xuY29uc3QgYWR2ZWN0aW9uUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGFkdmVjdGlvblNoYWRlcik7XG5jb25zdCBkaXZlcmdlbmNlUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGRpdmVyZ2VuY2VTaGFkZXIpO1xuY29uc3QgY3VybFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjdXJsU2hhZGVyKTtcbmNvbnN0IHZvcnRpY2l0eVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCB2b3J0aWNpdHlTaGFkZXIpO1xuY29uc3QgcHJlc3N1cmVQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgcHJlc3N1cmVTaGFkZXIpO1xuY29uc3QgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKFxuICBiYXNlVmVydGV4U2hhZGVyLFxuICBncmFkaWVudFN1YnRyYWN0U2hhZGVyXG4pO1xuXG5jb25zdCBkaXNwbGF5TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoYmFzZVZlcnRleFNoYWRlciwgZGlzcGxheVNoYWRlclNvdXJjZSk7XG5cbmZ1bmN0aW9uIGluaXRGcmFtZWJ1ZmZlcnMoKSB7XG4gIGxldCBzaW1SZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5TSU1fUkVTT0xVVElPTik7XG4gIGxldCBkeWVSZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5EWUVfUkVTT0xVVElPTik7XG5cbiAgY29uc3QgdGV4VHlwZSA9IGV4dC5oYWxmRmxvYXRUZXhUeXBlO1xuICBjb25zdCByZ2JhID0gZXh0LmZvcm1hdFJHQkE7XG4gIGNvbnN0IHJnID0gZXh0LmZvcm1hdFJHO1xuICBjb25zdCByID0gZXh0LmZvcm1hdFI7XG4gIGNvbnN0IGZpbHRlcmluZyA9IGV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcblxuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICBpZiAoZHllID09IG51bGwpXG4gICAgZHllID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgZHllUmVzLmhlaWdodCxcbiAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICByZ2JhLmZvcm1hdCxcbiAgICAgIHRleFR5cGUsXG4gICAgICBmaWx0ZXJpbmdcbiAgICApO1xuICBlbHNlXG4gICAgZHllID0gcmVzaXplRG91YmxlRkJPKFxuICAgICAgZHllLFxuICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgZHllUmVzLmhlaWdodCxcbiAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICByZ2JhLmZvcm1hdCxcbiAgICAgIHRleFR5cGUsXG4gICAgICBmaWx0ZXJpbmdcbiAgICApO1xuXG4gIGlmICh2ZWxvY2l0eSA9PSBudWxsKVxuICAgIHZlbG9jaXR5ID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgIHJnLmludGVybmFsRm9ybWF0LFxuICAgICAgcmcuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgICk7XG4gIGVsc2VcbiAgICB2ZWxvY2l0eSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgIHZlbG9jaXR5LFxuICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgIHJnLmludGVybmFsRm9ybWF0LFxuICAgICAgcmcuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgICk7XG5cbiAgZGl2ZXJnZW5jZSA9IGNyZWF0ZUZCTyhcbiAgICBzaW1SZXMud2lkdGgsXG4gICAgc2ltUmVzLmhlaWdodCxcbiAgICByLmludGVybmFsRm9ybWF0LFxuICAgIHIuZm9ybWF0LFxuICAgIHRleFR5cGUsXG4gICAgZ2wuTkVBUkVTVFxuICApO1xuICBjdXJsID0gY3JlYXRlRkJPKFxuICAgIHNpbVJlcy53aWR0aCxcbiAgICBzaW1SZXMuaGVpZ2h0LFxuICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgci5mb3JtYXQsXG4gICAgdGV4VHlwZSxcbiAgICBnbC5ORUFSRVNUXG4gICk7XG4gIHByZXNzdXJlID0gY3JlYXRlRG91YmxlRkJPKFxuICAgIHNpbVJlcy53aWR0aCxcbiAgICBzaW1SZXMuaGVpZ2h0LFxuICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgci5mb3JtYXQsXG4gICAgdGV4VHlwZSxcbiAgICBnbC5ORUFSRVNUXG4gICk7XG5cbiAgaW5pdEJsb29tRnJhbWVidWZmZXJzKCk7XG4gIGluaXRTdW5yYXlzRnJhbWVidWZmZXJzKCk7XG59XG5cbmZ1bmN0aW9uIGluaXRCbG9vbUZyYW1lYnVmZmVycygpIHtcbiAgbGV0IHJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLkJMT09NX1JFU09MVVRJT04pO1xuXG4gIGNvbnN0IHRleFR5cGUgPSBleHQuaGFsZkZsb2F0VGV4VHlwZTtcbiAgY29uc3QgcmdiYSA9IGV4dC5mb3JtYXRSR0JBO1xuICBjb25zdCBmaWx0ZXJpbmcgPSBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG5cbiAgYmxvb20gPSBjcmVhdGVGQk8oXG4gICAgcmVzLndpZHRoLFxuICAgIHJlcy5oZWlnaHQsXG4gICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICByZ2JhLmZvcm1hdCxcbiAgICB0ZXhUeXBlLFxuICAgIGZpbHRlcmluZ1xuICApO1xuXG4gIGJsb29tRnJhbWVidWZmZXJzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLkJMT09NX0lURVJBVElPTlM7IGkrKykge1xuICAgIGxldCB3aWR0aCA9IHJlcy53aWR0aCA+PiAoaSArIDEpO1xuICAgIGxldCBoZWlnaHQgPSByZXMuaGVpZ2h0ID4+IChpICsgMSk7XG5cbiAgICBpZiAod2lkdGggPCAyIHx8IGhlaWdodCA8IDIpIGJyZWFrO1xuXG4gICAgbGV0IGZibyA9IGNyZWF0ZUZCTyhcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHJnYmEuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgICk7XG4gICAgYmxvb21GcmFtZWJ1ZmZlcnMucHVzaChmYm8pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdW5yYXlzRnJhbWVidWZmZXJzKCkge1xuICBsZXQgcmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuU1VOUkFZU19SRVNPTFVUSU9OKTtcblxuICBjb25zdCB0ZXhUeXBlID0gZXh0LmhhbGZGbG9hdFRleFR5cGU7XG4gIGNvbnN0IHIgPSBleHQuZm9ybWF0UjtcbiAgY29uc3QgZmlsdGVyaW5nID0gZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUO1xuXG4gIHN1bnJheXMgPSBjcmVhdGVGQk8oXG4gICAgcmVzLndpZHRoLFxuICAgIHJlcy5oZWlnaHQsXG4gICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICByLmZvcm1hdCxcbiAgICB0ZXhUeXBlLFxuICAgIGZpbHRlcmluZ1xuICApO1xuICBzdW5yYXlzVGVtcCA9IGNyZWF0ZUZCTyhcbiAgICByZXMud2lkdGgsXG4gICAgcmVzLmhlaWdodCxcbiAgICByLmludGVybmFsRm9ybWF0LFxuICAgIHIuZm9ybWF0LFxuICAgIHRleFR5cGUsXG4gICAgZmlsdGVyaW5nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgbGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW0pO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW0pO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIHcsIGgsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG5cbiAgbGV0IGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgZ2wuVEVYVFVSRV8yRCxcbiAgICB0ZXh0dXJlLFxuICAgIDBcbiAgKTtcbiAgZ2wudmlld3BvcnQoMCwgMCwgdywgaCk7XG4gIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG4gIGxldCB0ZXhlbFNpemVYID0gMS4wIC8gdztcbiAgbGV0IHRleGVsU2l6ZVkgPSAxLjAgLyBoO1xuXG4gIHJldHVybiB7XG4gICAgdGV4dHVyZSxcbiAgICBmYm8sXG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoLFxuICAgIHRleGVsU2l6ZVgsXG4gICAgdGV4ZWxTaXplWSxcbiAgICBhdHRhY2goaWQpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpZCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEb3VibGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pIHtcbiAgbGV0IGZibzEgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICBsZXQgZmJvMiA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdGV4ZWxTaXplWDogZmJvMS50ZXhlbFNpemVYLFxuICAgIHRleGVsU2l6ZVk6IGZibzEudGV4ZWxTaXplWSxcbiAgICBnZXQgcmVhZCgpIHtcbiAgICAgIHJldHVybiBmYm8xO1xuICAgIH0sXG4gICAgc2V0IHJlYWQodmFsdWUpIHtcbiAgICAgIGZibzEgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCB3cml0ZSgpIHtcbiAgICAgIHJldHVybiBmYm8yO1xuICAgIH0sXG4gICAgc2V0IHdyaXRlKHZhbHVlKSB7XG4gICAgICBmYm8yID0gdmFsdWU7XG4gICAgfSxcbiAgICBzd2FwKCkge1xuICAgICAgbGV0IHRlbXAgPSBmYm8xO1xuICAgICAgZmJvMSA9IGZibzI7XG4gICAgICBmYm8yID0gdGVtcDtcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNpemVGQk8odGFyZ2V0LCB3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSkge1xuICBsZXQgbmV3RkJPID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgY29weVByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMWkoY29weVByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHRhcmdldC5hdHRhY2goMCkpO1xuICBibGl0KG5ld0ZCTyk7XG4gIHJldHVybiBuZXdGQk87XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZURvdWJsZUZCTyh0YXJnZXQsIHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKSB7XG4gIGlmICh0YXJnZXQud2lkdGggPT0gdyAmJiB0YXJnZXQuaGVpZ2h0ID09IGgpIHJldHVybiB0YXJnZXQ7XG4gIHRhcmdldC5yZWFkID0gcmVzaXplRkJPKFxuICAgIHRhcmdldC5yZWFkLFxuICAgIHcsXG4gICAgaCxcbiAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICBmb3JtYXQsXG4gICAgdHlwZSxcbiAgICBwYXJhbVxuICApO1xuICB0YXJnZXQud3JpdGUgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICB0YXJnZXQud2lkdGggPSB3O1xuICB0YXJnZXQuaGVpZ2h0ID0gaDtcbiAgdGFyZ2V0LnRleGVsU2l6ZVggPSAxLjAgLyB3O1xuICB0YXJnZXQudGV4ZWxTaXplWSA9IDEuMCAvIGg7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVBc3luYyh1cmwpIHtcbiAgbGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gIGdsLnRleEltYWdlMkQoXG4gICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAwLFxuICAgIGdsLlJHQixcbiAgICAxLFxuICAgIDEsXG4gICAgMCxcbiAgICBnbC5SR0IsXG4gICAgZ2wuVU5TSUdORURfQllURSxcbiAgICBuZXcgVWludDhBcnJheShbMjU1LCAyNTUsIDI1NV0pXG4gICk7XG5cbiAgbGV0IG9iaiA9IHtcbiAgICB0ZXh0dXJlLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBhdHRhY2goaWQpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpZCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICB9O1xuXG4gIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgb2JqLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgb2JqLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gIH07XG4gIGltYWdlLnNyYyA9IHVybDtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVLZXl3b3JkcygpIHtcbiAgbGV0IGRpc3BsYXlLZXl3b3JkcyA9IFtdO1xuICBpZiAoY29uZmlnLlNIQURJTkcpIGRpc3BsYXlLZXl3b3Jkcy5wdXNoKCdTSEFESU5HJyk7XG4gIGlmIChjb25maWcuQkxPT00pIGRpc3BsYXlLZXl3b3Jkcy5wdXNoKCdCTE9PTScpO1xuICBpZiAoY29uZmlnLlNVTlJBWVMpIGRpc3BsYXlLZXl3b3Jkcy5wdXNoKCdTVU5SQVlTJyk7XG4gIGRpc3BsYXlNYXRlcmlhbC5zZXRLZXl3b3JkcyhkaXNwbGF5S2V5d29yZHMpO1xufVxuXG51cGRhdGVLZXl3b3JkcygpO1xuaW5pdEZyYW1lYnVmZmVycygpO1xubXVsdGlwbGVTcGxhdHMocGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDIwKSArIDUpO1xuXG5sZXQgbGFzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xubGV0IGNvbG9yVXBkYXRlVGltZXIgPSAwLjA7XG51cGRhdGUoKTtcblxuZnVuY3Rpb24gdXBkYXRlKCkge1xuICBjb25zdCBkdCA9IGNhbGNEZWx0YVRpbWUoKTtcbiAgaWYgKHJlc2l6ZUNhbnZhcygpKSBpbml0RnJhbWVidWZmZXJzKCk7XG4gIHVwZGF0ZUNvbG9ycyhkdCk7XG4gIGFwcGx5SW5wdXRzKCk7XG4gIGlmICghY29uZmlnLlBBVVNFRCkgc3RlcChkdCk7XG4gIHJlbmRlcihudWxsKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbGNEZWx0YVRpbWUoKSB7XG4gIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICBsZXQgZHQgPSAobm93IC0gbGFzdFVwZGF0ZVRpbWUpIC8gMTAwMDtcbiAgZHQgPSBNYXRoLm1pbihkdCwgMC4wMTY2NjYpO1xuICBsYXN0VXBkYXRlVGltZSA9IG5vdztcbiAgcmV0dXJuIGR0O1xufVxuXG5mdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG4gIGxldCB3aWR0aCA9IHNjYWxlQnlQaXhlbFJhdGlvKGNhbnZhcy5jbGllbnRXaWR0aCk7XG4gIGxldCBoZWlnaHQgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhjYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgaWYgKGNhbnZhcy53aWR0aCAhPSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb2xvcnMoZHQpIHtcbiAgaWYgKCFjb25maWcuQ09MT1JGVUwpIHJldHVybjtcblxuICBjb2xvclVwZGF0ZVRpbWVyICs9IGR0ICogY29uZmlnLkNPTE9SX1VQREFURV9TUEVFRDtcbiAgaWYgKGNvbG9yVXBkYXRlVGltZXIgPj0gMSkge1xuICAgIGNvbG9yVXBkYXRlVGltZXIgPSB3cmFwKGNvbG9yVXBkYXRlVGltZXIsIDAsIDEpO1xuICAgIHBvaW50ZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgIHAuY29sb3IgPSBnZW5lcmF0ZUNvbG9yKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlJbnB1dHMoKSB7XG4gIGlmIChzcGxhdFN0YWNrLmxlbmd0aCA+IDApIG11bHRpcGxlU3BsYXRzKHNwbGF0U3RhY2sucG9wKCkpO1xuXG4gIHBvaW50ZXJzLmZvckVhY2goKHApID0+IHtcbiAgICBpZiAocC5tb3ZlZCkge1xuICAgICAgcC5tb3ZlZCA9IGZhbHNlO1xuICAgICAgc3BsYXRQb2ludGVyKHApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0ZXAoZHQpIHtcbiAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgY3VybFByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMmYoXG4gICAgY3VybFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICApO1xuICBnbC51bmlmb3JtMWkoY3VybFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSk7XG4gIGJsaXQoY3VybCk7XG5cbiAgdm9ydGljaXR5UHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0yZihcbiAgICB2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgKTtcbiAgZ2wudW5pZm9ybTFpKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSk7XG4gIGdsLnVuaWZvcm0xaSh2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnVDdXJsLCBjdXJsLmF0dGFjaCgxKSk7XG4gIGdsLnVuaWZvcm0xZih2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLmN1cmwsIGNvbmZpZy5DVVJMKTtcbiAgZ2wudW5pZm9ybTFmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuZHQsIGR0KTtcbiAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gIHZlbG9jaXR5LnN3YXAoKTtcblxuICBkaXZlcmdlbmNlUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0yZihcbiAgICBkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICk7XG4gIGdsLnVuaWZvcm0xaShkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgYmxpdChkaXZlcmdlbmNlKTtcblxuICBjbGVhclByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMWkoY2xlYXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKSk7XG4gIGdsLnVuaWZvcm0xZihjbGVhclByb2dyYW0udW5pZm9ybXMudmFsdWUsIGNvbmZpZy5QUkVTU1VSRSk7XG4gIGJsaXQocHJlc3N1cmUud3JpdGUpO1xuICBwcmVzc3VyZS5zd2FwKCk7XG5cbiAgcHJlc3N1cmVQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTJmKFxuICAgIHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICk7XG4gIGdsLnVuaWZvcm0xaShwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudURpdmVyZ2VuY2UsIGRpdmVyZ2VuY2UuYXR0YWNoKDApKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcuUFJFU1NVUkVfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgZ2wudW5pZm9ybTFpKHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51UHJlc3N1cmUsIHByZXNzdXJlLnJlYWQuYXR0YWNoKDEpKTtcbiAgICBibGl0KHByZXNzdXJlLndyaXRlKTtcbiAgICBwcmVzc3VyZS5zd2FwKCk7XG4gIH1cblxuICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTJmKFxuICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICApO1xuICBnbC51bmlmb3JtMWkoXG4gICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy51UHJlc3N1cmUsXG4gICAgcHJlc3N1cmUucmVhZC5hdHRhY2goMClcbiAgKTtcbiAgZ2wudW5pZm9ybTFpKFxuICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDEpXG4gICk7XG4gIGJsaXQodmVsb2NpdHkud3JpdGUpO1xuICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgYWR2ZWN0aW9uUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0yZihcbiAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgKTtcbiAgaWYgKCFleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZylcbiAgICBnbC51bmlmb3JtMmYoXG4gICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmR5ZVRleGVsU2l6ZSxcbiAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgKTtcbiAgbGV0IHZlbG9jaXR5SWQgPSB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKTtcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eUlkKTtcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgdmVsb2NpdHlJZCk7XG4gIGdsLnVuaWZvcm0xZihhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmR0LCBkdCk7XG4gIGdsLnVuaWZvcm0xZihcbiAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLFxuICAgIGNvbmZpZy5WRUxPQ0lUWV9ESVNTSVBBVElPTlxuICApO1xuICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gIGlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpXG4gICAgZ2wudW5pZm9ybTJmKFxuICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsXG4gICAgICBkeWUudGV4ZWxTaXplWCxcbiAgICAgIGR5ZS50ZXhlbFNpemVZXG4gICAgKTtcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSk7XG4gIGdsLnVuaWZvcm0xaShhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UsIGR5ZS5yZWFkLmF0dGFjaCgxKSk7XG4gIGdsLnVuaWZvcm0xZihcbiAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLFxuICAgIGNvbmZpZy5ERU5TSVRZX0RJU1NJUEFUSU9OXG4gICk7XG4gIGJsaXQoZHllLndyaXRlKTtcbiAgZHllLnN3YXAoKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKHRhcmdldCkge1xuICBpZiAoY29uZmlnLkJMT09NKSBhcHBseUJsb29tKGR5ZS5yZWFkLCBibG9vbSk7XG4gIGlmIChjb25maWcuU1VOUkFZUykge1xuICAgIGFwcGx5U3VucmF5cyhkeWUucmVhZCwgZHllLndyaXRlLCBzdW5yYXlzKTtcbiAgICBibHVyKHN1bnJheXMsIHN1bnJheXNUZW1wLCAxKTtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT0gbnVsbCB8fCAhY29uZmlnLlRSQU5TUEFSRU5UKSB7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgfSBlbHNlIHtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgfVxuXG4gIGlmICghY29uZmlnLlRSQU5TUEFSRU5UKSBkcmF3Q29sb3IodGFyZ2V0LCBub3JtYWxpemVDb2xvcihjb25maWcuQkFDS19DT0xPUikpO1xuICBpZiAodGFyZ2V0ID09IG51bGwgJiYgY29uZmlnLlRSQU5TUEFSRU5UKSBkcmF3Q2hlY2tlcmJvYXJkKHRhcmdldCk7XG4gIGRyYXdEaXNwbGF5KHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdDb2xvcih0YXJnZXQsIGNvbG9yKSB7XG4gIGNvbG9yUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm00Zihjb2xvclByb2dyYW0udW5pZm9ybXMuY29sb3IsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIDEpO1xuICBibGl0KHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdDaGVja2VyYm9hcmQodGFyZ2V0KSB7XG4gIGNoZWNrZXJib2FyZFByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMWYoXG4gICAgY2hlY2tlcmJvYXJkUHJvZ3JhbS51bmlmb3Jtcy5hc3BlY3RSYXRpbyxcbiAgICBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0XG4gICk7XG4gIGJsaXQodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gZHJhd0Rpc3BsYXkodGFyZ2V0KSB7XG4gIGxldCB3aWR0aCA9IHRhcmdldCA9PSBudWxsID8gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIDogdGFyZ2V0LndpZHRoO1xuICBsZXQgaGVpZ2h0ID0gdGFyZ2V0ID09IG51bGwgPyBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IDogdGFyZ2V0LmhlaWdodDtcblxuICBkaXNwbGF5TWF0ZXJpYWwuYmluZCgpO1xuICBpZiAoY29uZmlnLlNIQURJTkcpXG4gICAgZ2wudW5pZm9ybTJmKGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy50ZXhlbFNpemUsIDEuMCAvIHdpZHRoLCAxLjAgLyBoZWlnaHQpO1xuICBnbC51bmlmb3JtMWkoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnVUZXh0dXJlLCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICBpZiAoY29uZmlnLkJMT09NKSB7XG4gICAgZ2wudW5pZm9ybTFpKGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy51Qmxvb20sIGJsb29tLmF0dGFjaCgxKSk7XG4gICAgZ2wudW5pZm9ybTFpKFxuICAgICAgZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnVEaXRoZXJpbmcsXG4gICAgICBkaXRoZXJpbmdUZXh0dXJlLmF0dGFjaCgyKVxuICAgICk7XG4gICAgbGV0IHNjYWxlID0gZ2V0VGV4dHVyZVNjYWxlKGRpdGhlcmluZ1RleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGdsLnVuaWZvcm0yZihkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMuZGl0aGVyU2NhbGUsIHNjYWxlLngsIHNjYWxlLnkpO1xuICB9XG4gIGlmIChjb25maWcuU1VOUkFZUylcbiAgICBnbC51bmlmb3JtMWkoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnVTdW5yYXlzLCBzdW5yYXlzLmF0dGFjaCgzKSk7XG4gIGJsaXQodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlCbG9vbShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGlmIChibG9vbUZyYW1lYnVmZmVycy5sZW5ndGggPCAyKSByZXR1cm47XG5cbiAgbGV0IGxhc3QgPSBkZXN0aW5hdGlvbjtcblxuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgYmxvb21QcmVmaWx0ZXJQcm9ncmFtLmJpbmQoKTtcbiAgbGV0IGtuZWUgPSBjb25maWcuQkxPT01fVEhSRVNIT0xEICogY29uZmlnLkJMT09NX1NPRlRfS05FRSArIDAuMDAwMTtcbiAgbGV0IGN1cnZlMCA9IGNvbmZpZy5CTE9PTV9USFJFU0hPTEQgLSBrbmVlO1xuICBsZXQgY3VydmUxID0ga25lZSAqIDI7XG4gIGxldCBjdXJ2ZTIgPSAwLjI1IC8ga25lZTtcbiAgZ2wudW5pZm9ybTNmKGJsb29tUHJlZmlsdGVyUHJvZ3JhbS51bmlmb3Jtcy5jdXJ2ZSwgY3VydmUwLCBjdXJ2ZTEsIGN1cnZlMik7XG4gIGdsLnVuaWZvcm0xZihcbiAgICBibG9vbVByZWZpbHRlclByb2dyYW0udW5pZm9ybXMudGhyZXNob2xkLFxuICAgIGNvbmZpZy5CTE9PTV9USFJFU0hPTERcbiAgKTtcbiAgZ2wudW5pZm9ybTFpKGJsb29tUHJlZmlsdGVyUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgc291cmNlLmF0dGFjaCgwKSk7XG4gIGJsaXQobGFzdCk7XG5cbiAgYmxvb21CbHVyUHJvZ3JhbS5iaW5kKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvb21GcmFtZWJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZGVzdCA9IGJsb29tRnJhbWVidWZmZXJzW2ldO1xuICAgIGdsLnVuaWZvcm0yZihcbiAgICAgIGJsb29tQmx1clByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgbGFzdC50ZXhlbFNpemVYLFxuICAgICAgbGFzdC50ZXhlbFNpemVZXG4gICAgKTtcbiAgICBnbC51bmlmb3JtMWkoYmxvb21CbHVyUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgbGFzdC5hdHRhY2goMCkpO1xuICAgIGJsaXQoZGVzdCk7XG4gICAgbGFzdCA9IGRlc3Q7XG4gIH1cblxuICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gIGZvciAobGV0IGkgPSBibG9vbUZyYW1lYnVmZmVycy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgIGxldCBiYXNlVGV4ID0gYmxvb21GcmFtZWJ1ZmZlcnNbaV07XG4gICAgZ2wudW5pZm9ybTJmKFxuICAgICAgYmxvb21CbHVyUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICBsYXN0LnRleGVsU2l6ZVgsXG4gICAgICBsYXN0LnRleGVsU2l6ZVlcbiAgICApO1xuICAgIGdsLnVuaWZvcm0xaShibG9vbUJsdXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBsYXN0LmF0dGFjaCgwKSk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgYmFzZVRleC53aWR0aCwgYmFzZVRleC5oZWlnaHQpO1xuICAgIGJsaXQoYmFzZVRleCk7XG4gICAgbGFzdCA9IGJhc2VUZXg7XG4gIH1cblxuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgYmxvb21GaW5hbFByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMmYoXG4gICAgYmxvb21GaW5hbFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgIGxhc3QudGV4ZWxTaXplWCxcbiAgICBsYXN0LnRleGVsU2l6ZVlcbiAgKTtcbiAgZ2wudW5pZm9ybTFpKGJsb29tRmluYWxQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBsYXN0LmF0dGFjaCgwKSk7XG4gIGdsLnVuaWZvcm0xZihibG9vbUZpbmFsUHJvZ3JhbS51bmlmb3Jtcy5pbnRlbnNpdHksIGNvbmZpZy5CTE9PTV9JTlRFTlNJVFkpO1xuICBibGl0KGRlc3RpbmF0aW9uKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlTdW5yYXlzKHNvdXJjZSwgbWFzaywgZGVzdGluYXRpb24pIHtcbiAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gIHN1bnJheXNNYXNrUHJvZ3JhbS5iaW5kKCk7XG4gIGdsLnVuaWZvcm0xaShzdW5yYXlzTWFza1Byb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHNvdXJjZS5hdHRhY2goMCkpO1xuICBibGl0KG1hc2spO1xuXG4gIHN1bnJheXNQcm9ncmFtLmJpbmQoKTtcbiAgZ2wudW5pZm9ybTFmKHN1bnJheXNQcm9ncmFtLnVuaWZvcm1zLndlaWdodCwgY29uZmlnLlNVTlJBWVNfV0VJR0hUKTtcbiAgZ2wudW5pZm9ybTFpKHN1bnJheXNQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBtYXNrLmF0dGFjaCgwKSk7XG4gIGJsaXQoZGVzdGluYXRpb24pO1xufVxuXG5mdW5jdGlvbiBibHVyKHRhcmdldCwgdGVtcCwgaXRlcmF0aW9ucykge1xuICBibHVyUHJvZ3JhbS5iaW5kKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgZ2wudW5pZm9ybTJmKGJsdXJQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgdGFyZ2V0LnRleGVsU2l6ZVgsIDAuMCk7XG4gICAgZ2wudW5pZm9ybTFpKGJsdXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCB0YXJnZXQuYXR0YWNoKDApKTtcbiAgICBibGl0KHRlbXApO1xuXG4gICAgZ2wudW5pZm9ybTJmKGJsdXJQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgMC4wLCB0YXJnZXQudGV4ZWxTaXplWSk7XG4gICAgZ2wudW5pZm9ybTFpKGJsdXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCB0ZW1wLmF0dGFjaCgwKSk7XG4gICAgYmxpdCh0YXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNwbGF0UG9pbnRlcihwb2ludGVyKSB7XG4gIGxldCBkeCA9IHBvaW50ZXIuZGVsdGFYICogY29uZmlnLlNQTEFUX0ZPUkNFO1xuICBsZXQgZHkgPSBwb2ludGVyLmRlbHRhWSAqIGNvbmZpZy5TUExBVF9GT1JDRTtcbiAgc3BsYXQocG9pbnRlci50ZXhjb29yZFgsIHBvaW50ZXIudGV4Y29vcmRZLCBkeCwgZHksIHBvaW50ZXIuY29sb3IpO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZVNwbGF0cyhhbW91bnQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgIGNvbnN0IGNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xuICAgIGNvbG9yLnIgKj0gMTAuMDtcbiAgICBjb2xvci5nICo9IDEwLjA7XG4gICAgY29sb3IuYiAqPSAxMC4wO1xuICAgIGNvbnN0IHggPSBNYXRoLnJhbmRvbSgpO1xuICAgIGNvbnN0IHkgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGNvbnN0IGR4ID0gMTAwMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICBjb25zdCBkeSA9IDEwMDAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgc3BsYXQoeCwgeSwgZHgsIGR5LCBjb2xvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsYXQoeCwgeSwgZHgsIGR5LCBjb2xvcikge1xuICBzcGxhdFByb2dyYW0uYmluZCgpO1xuICBnbC51bmlmb3JtMWkoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnVUYXJnZXQsIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKTtcbiAgZ2wudW5pZm9ybTFmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5hc3BlY3RSYXRpbywgY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodCk7XG4gIGdsLnVuaWZvcm0yZihzcGxhdFByb2dyYW0udW5pZm9ybXMucG9pbnQsIHgsIHkpO1xuICBnbC51bmlmb3JtM2Yoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmNvbG9yLCBkeCwgZHksIDAuMCk7XG4gIGdsLnVuaWZvcm0xZihcbiAgICBzcGxhdFByb2dyYW0udW5pZm9ybXMucmFkaXVzLFxuICAgIGNvcnJlY3RSYWRpdXMoY29uZmlnLlNQTEFUX1JBRElVUyAvIDEwMC4wKVxuICApO1xuICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgdmVsb2NpdHkuc3dhcCgpO1xuXG4gIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgZHllLnJlYWQuYXR0YWNoKDApKTtcbiAgZ2wudW5pZm9ybTNmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIGJsaXQoZHllLndyaXRlKTtcbiAgZHllLnN3YXAoKTtcbn1cblxuZnVuY3Rpb24gY29ycmVjdFJhZGl1cyhyYWRpdXMpIHtcbiAgbGV0IGFzcGVjdFJhdGlvID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDtcbiAgaWYgKGFzcGVjdFJhdGlvID4gMSkgcmFkaXVzICo9IGFzcGVjdFJhdGlvO1xuICByZXR1cm4gcmFkaXVzO1xufVxuXG5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcbiAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLm9mZnNldFgpO1xuICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUub2Zmc2V0WSk7XG4gIGxldCBwb2ludGVyID0gcG9pbnRlcnMuZmluZCgocCkgPT4gcC5pZCA9PSAtMSk7XG4gIGlmIChwb2ludGVyID09IG51bGwpIHBvaW50ZXIgPSBuZXcgcG9pbnRlclByb3RvdHlwZSgpO1xuICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgLTEsIHBvc1gsIHBvc1kpO1xufSk7XG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICBpZiAoIXBvaW50ZXIuZG93bikgcmV0dXJuO1xuICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUub2Zmc2V0WCk7XG4gIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5vZmZzZXRZKTtcbiAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpO1xufSk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXJzWzBdKTtcbn0pO1xuXG5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChlKSA9PiB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgd2hpbGUgKHRvdWNoZXMubGVuZ3RoID49IHBvaW50ZXJzLmxlbmd0aClcbiAgICBwb2ludGVycy5wdXNoKG5ldyBwb2ludGVyUHJvdG90eXBlKCkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKHRvdWNoZXNbaV0ucGFnZVgpO1xuICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5wYWdlWSk7XG4gICAgdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXJzW2kgKyAxXSwgdG91Y2hlc1tpXS5pZGVudGlmaWVyLCBwb3NYLCBwb3NZKTtcbiAgfVxufSk7XG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFxuICAndG91Y2htb3ZlJyxcbiAgKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnNbaSArIDFdO1xuICAgICAgaWYgKCFwb2ludGVyLmRvd24pIGNvbnRpbnVlO1xuICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLnBhZ2VYKTtcbiAgICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5wYWdlWSk7XG4gICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSk7XG4gICAgfVxuICB9LFxuICBmYWxzZVxuKTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGUpID0+IHtcbiAgY29uc3QgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnMuZmluZCgocCkgPT4gcC5pZCA9PSB0b3VjaGVzW2ldLmlkZW50aWZpZXIpO1xuICAgIGlmIChwb2ludGVyID09IG51bGwpIGNvbnRpbnVlO1xuICAgIHVwZGF0ZVBvaW50ZXJVcERhdGEocG9pbnRlcik7XG4gIH1cbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gIGlmIChlLmNvZGUgPT09ICdLZXlQJykgY29uZmlnLlBBVVNFRCA9ICFjb25maWcuUEFVU0VEO1xuICBpZiAoZS5rZXkgPT09ICcgJykgc3BsYXRTdGFjay5wdXNoKHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiAyMCkgKyA1KTtcbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgaWQsIHBvc1gsIHBvc1kpIHtcbiAgcG9pbnRlci5pZCA9IGlkO1xuICBwb2ludGVyLmRvd24gPSB0cnVlO1xuICBwb2ludGVyLm1vdmVkID0gZmFsc2U7XG4gIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcy53aWR0aDtcbiAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodDtcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICBwb2ludGVyLmRlbHRhWCA9IDA7XG4gIHBvaW50ZXIuZGVsdGFZID0gMDtcbiAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpIHtcbiAgcG9pbnRlci5wcmV2VGV4Y29vcmRYID0gcG9pbnRlci50ZXhjb29yZFg7XG4gIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMud2lkdGg7XG4gIHBvaW50ZXIudGV4Y29vcmRZID0gMS4wIC0gcG9zWSAvIGNhbnZhcy5oZWlnaHQ7XG4gIHBvaW50ZXIuZGVsdGFYID0gY29ycmVjdERlbHRhWChwb2ludGVyLnRleGNvb3JkWCAtIHBvaW50ZXIucHJldlRleGNvb3JkWCk7XG4gIHBvaW50ZXIuZGVsdGFZID0gY29ycmVjdERlbHRhWShwb2ludGVyLnRleGNvb3JkWSAtIHBvaW50ZXIucHJldlRleGNvb3JkWSk7XG4gIHBvaW50ZXIubW92ZWQgPSBNYXRoLmFicyhwb2ludGVyLmRlbHRhWCkgPiAwIHx8IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFZKSA+IDA7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJVcERhdGEocG9pbnRlcikge1xuICBwb2ludGVyLmRvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29ycmVjdERlbHRhWChkZWx0YSkge1xuICBsZXQgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0O1xuICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBkZWx0YSAqPSBhc3BlY3RSYXRpbztcbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0RGVsdGFZKGRlbHRhKSB7XG4gIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQ7XG4gIGlmIChhc3BlY3RSYXRpbyA+IDEpIGRlbHRhIC89IGFzcGVjdFJhdGlvO1xuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sb3IoKSB7XG4gIGxldCBjID0gSFNWdG9SR0IoTWF0aC5yYW5kb20oKSwgMS4wLCAxLjApO1xuICBjLnIgKj0gMC4xNTtcbiAgYy5nICo9IDAuMTU7XG4gIGMuYiAqPSAwLjE1O1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xuICBsZXQgciwgZywgYiwgaSwgZiwgcCwgcSwgdDtcbiAgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICBmID0gaCAqIDYgLSBpO1xuICBwID0gdiAqICgxIC0gcyk7XG4gIHEgPSB2ICogKDEgLSBmICogcyk7XG4gIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDpcbiAgICAgIChyID0gdiksIChnID0gdCksIChiID0gcCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICAociA9IHEpLCAoZyA9IHYpLCAoYiA9IHApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgKHIgPSBwKSwgKGcgPSB2KSwgKGIgPSB0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIChyID0gcCksIChnID0gcSksIChiID0gdik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICAociA9IHQpLCAoZyA9IHApLCAoYiA9IHYpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgKHIgPSB2KSwgKGcgPSBwKSwgKGIgPSBxKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByLFxuICAgIGcsXG4gICAgYixcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoaW5wdXQpIHtcbiAgbGV0IG91dHB1dCA9IHtcbiAgICByOiBpbnB1dC5yIC8gMjU1LFxuICAgIGc6IGlucHV0LmcgLyAyNTUsXG4gICAgYjogaW5wdXQuYiAvIDI1NSxcbiAgfTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gd3JhcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgbGV0IHJhbmdlID0gbWF4IC0gbWluO1xuICBpZiAocmFuZ2UgPT0gMCkgcmV0dXJuIG1pbjtcbiAgcmV0dXJuICgodmFsdWUgLSBtaW4pICUgcmFuZ2UpICsgbWluO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgbGV0IGFzcGVjdFJhdGlvID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIC8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgaWYgKGFzcGVjdFJhdGlvIDwgMSkgYXNwZWN0UmF0aW8gPSAxLjAgLyBhc3BlY3RSYXRpbztcblxuICBsZXQgbWluID0gTWF0aC5yb3VuZChyZXNvbHV0aW9uKTtcbiAgbGV0IG1heCA9IE1hdGgucm91bmQocmVzb2x1dGlvbiAqIGFzcGVjdFJhdGlvKTtcblxuICBpZiAoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoID4gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodClcbiAgICByZXR1cm4geyB3aWR0aDogbWF4LCBoZWlnaHQ6IG1pbiB9O1xuICBlbHNlIHJldHVybiB7IHdpZHRoOiBtaW4sIGhlaWdodDogbWF4IH07XG59XG5cbmZ1bmN0aW9uIGdldFRleHR1cmVTY2FsZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgeDogd2lkdGggLyB0ZXh0dXJlLndpZHRoLFxuICAgIHk6IGhlaWdodCAvIHRleHR1cmUuaGVpZ2h0LFxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FsZUJ5UGl4ZWxSYXRpbyhpbnB1dCkge1xuICBsZXQgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiBNYXRoLmZsb29yKGlucHV0ICogcGl4ZWxSYXRpbyk7XG59XG5cbmZ1bmN0aW9uIGhhc2hDb2RlKHMpIHtcbiAgaWYgKHMubGVuZ3RoID09IDApIHJldHVybiAwO1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbiJdLCJuYW1lcyI6WyJkb2N1bWVudCIsIndpbmRvdyIsImNhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwicmVzaXplQ2FudmFzIiwiY29uZmlnIiwiU0lNX1JFU09MVVRJT04iLCJEWUVfUkVTT0xVVElPTiIsIkNBUFRVUkVfUkVTT0xVVElPTiIsIkRFTlNJVFlfRElTU0lQQVRJT04iLCJWRUxPQ0lUWV9ESVNTSVBBVElPTiIsIlBSRVNTVVJFIiwiUFJFU1NVUkVfSVRFUkFUSU9OUyIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJTUExBVF9GT1JDRSIsIlNIQURJTkciLCJDT0xPUkZVTCIsIkNPTE9SX1VQREFURV9TUEVFRCIsIlBBVVNFRCIsIkJBQ0tfQ09MT1IiLCJyIiwiZyIsImIiLCJUUkFOU1BBUkVOVCIsIkJMT09NIiwiQkxPT01fSVRFUkFUSU9OUyIsIkJMT09NX1JFU09MVVRJT04iLCJCTE9PTV9JTlRFTlNJVFkiLCJCTE9PTV9USFJFU0hPTEQiLCJCTE9PTV9TT0ZUX0tORUUiLCJTVU5SQVlTIiwiU1VOUkFZU19SRVNPTFVUSU9OIiwiU1VOUkFZU19XRUlHSFQiLCJwb2ludGVyUHJvdG90eXBlIiwiaWQiLCJ0ZXhjb29yZFgiLCJ0ZXhjb29yZFkiLCJwcmV2VGV4Y29vcmRYIiwicHJldlRleGNvb3JkWSIsImRlbHRhWCIsImRlbHRhWSIsImRvd24iLCJtb3ZlZCIsImNvbG9yIiwicG9pbnRlcnMiLCJzcGxhdFN0YWNrIiwicHVzaCIsImdsIiwiZXh0IiwiZ2V0V2ViR0xDb250ZXh0IiwiaXNNb2JpbGUiLCJzdXBwb3J0TGluZWFyRmlsdGVyaW5nIiwicGFyYW1zIiwiYWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJnZXRDb250ZXh0IiwiaXNXZWJHTDIiLCJoYWxmRmxvYXQiLCJnZXRFeHRlbnNpb24iLCJjbGVhckNvbG9yIiwiaGFsZkZsb2F0VGV4VHlwZSIsIkhBTEZfRkxPQVQiLCJIQUxGX0ZMT0FUX09FUyIsImZvcm1hdFJHQkEiLCJmb3JtYXRSRyIsImZvcm1hdFIiLCJnZXRTdXBwb3J0ZWRGb3JtYXQiLCJSR0JBMTZGIiwiUkdCQSIsIlJHMTZGIiwiUkciLCJSMTZGIiwiUkVEIiwiaW50ZXJuYWxGb3JtYXQiLCJmb3JtYXQiLCJ0eXBlIiwic3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQiLCJ0ZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJORUFSRVNUIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJ0ZXhJbWFnZTJEIiwiZmJvIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJzdGF0dXMiLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY2FwdHVyZVNjcmVlbnNob3QiLCJyZXMiLCJnZXRSZXNvbHV0aW9uIiwidGFyZ2V0IiwiY3JlYXRlRkJPIiwid2lkdGgiLCJoZWlnaHQiLCJyZW5kZXIiLCJmcmFtZWJ1ZmZlclRvVGV4dHVyZSIsIm5vcm1hbGl6ZVRleHR1cmUiLCJjYXB0dXJlQ2FudmFzIiwidGV4dHVyZVRvQ2FudmFzIiwiZGF0YXVyaSIsInRvRGF0YVVSTCIsImRvd25sb2FkVVJJIiwiVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwibGVuZ3RoIiwiRmxvYXQzMkFycmF5IiwicmVhZFBpeGVscyIsIkZMT0FUIiwicmVzdWx0IiwiVWludDhBcnJheSIsImkiLCJqIiwibmlkIiwiY2xhbXAwMSIsImlucHV0IiwiTWF0aCIsIm1pbiIsIm1heCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJpbWFnZURhdGEiLCJjcmVhdGVJbWFnZURhdGEiLCJkYXRhIiwic2V0IiwicHV0SW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ1cmkiLCJsaW5rIiwiZG93bmxvYWQiLCJocmVmIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsIk1hdGVyaWFsIiwic2V0S2V5d29yZHMiLCJrZXl3b3JkcyIsImhhc2giLCJoYXNoQ29kZSIsInByb2dyYW0iLCJwcm9ncmFtcyIsImZyYWdtZW50U2hhZGVyIiwiY29tcGlsZVNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsImZyYWdtZW50U2hhZGVyU291cmNlIiwiY3JlYXRlUHJvZ3JhbSIsInZlcnRleFNoYWRlciIsImFjdGl2ZVByb2dyYW0iLCJ1bmlmb3JtcyIsImdldFVuaWZvcm1zIiwiYmluZCIsInVzZVByb2dyYW0iLCJjb25zdHJ1Y3RvciIsIlByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImNvbnNvbGUiLCJ0cmFjZSIsImdldFByb2dyYW1JbmZvTG9nIiwidW5pZm9ybUNvdW50IiwiQUNUSVZFX1VOSUZPUk1TIiwidW5pZm9ybU5hbWUiLCJnZXRBY3RpdmVVbmlmb3JtIiwibmFtZSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInNvdXJjZSIsImFkZEtleXdvcmRzIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJnZXRTaGFkZXJJbmZvTG9nIiwia2V5d29yZHNTdHJpbmciLCJmb3JFYWNoIiwia2V5d29yZCIsImJhc2VWZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiYmx1clZlcnRleFNoYWRlciIsImJsdXJTaGFkZXIiLCJjb3B5U2hhZGVyIiwiY2xlYXJTaGFkZXIiLCJjb2xvclNoYWRlciIsImNoZWNrZXJib2FyZFNoYWRlciIsImRpc3BsYXlTaGFkZXJTb3VyY2UiLCJibG9vbVByZWZpbHRlclNoYWRlciIsImJsb29tQmx1clNoYWRlciIsImJsb29tRmluYWxTaGFkZXIiLCJzdW5yYXlzTWFza1NoYWRlciIsInN1bnJheXNTaGFkZXIiLCJzcGxhdFNoYWRlciIsImFkdmVjdGlvblNoYWRlciIsImRpdmVyZ2VuY2VTaGFkZXIiLCJjdXJsU2hhZGVyIiwidm9ydGljaXR5U2hhZGVyIiwicHJlc3N1cmVTaGFkZXIiLCJncmFkaWVudFN1YnRyYWN0U2hhZGVyIiwiYmxpdCIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJjcmVhdGVCdWZmZXIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlVpbnQxNkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwiY2xlYXIiLCJ2aWV3cG9ydCIsImRyYXdpbmdCdWZmZXJXaWR0aCIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJDT0xPUl9CVUZGRVJfQklUIiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwiVU5TSUdORURfU0hPUlQiLCJDSEVDS19GUkFNRUJVRkZFUl9TVEFUVVMiLCJkeWUiLCJ2ZWxvY2l0eSIsImRpdmVyZ2VuY2UiLCJjdXJsIiwicHJlc3N1cmUiLCJibG9vbSIsImJsb29tRnJhbWVidWZmZXJzIiwic3VucmF5cyIsInN1bnJheXNUZW1wIiwiZGl0aGVyaW5nVGV4dHVyZSIsImNyZWF0ZVRleHR1cmVBc3luYyIsImJsdXJQcm9ncmFtIiwiY29weVByb2dyYW0iLCJjbGVhclByb2dyYW0iLCJjb2xvclByb2dyYW0iLCJjaGVja2VyYm9hcmRQcm9ncmFtIiwiYmxvb21QcmVmaWx0ZXJQcm9ncmFtIiwiYmxvb21CbHVyUHJvZ3JhbSIsImJsb29tRmluYWxQcm9ncmFtIiwic3VucmF5c01hc2tQcm9ncmFtIiwic3VucmF5c1Byb2dyYW0iLCJzcGxhdFByb2dyYW0iLCJhZHZlY3Rpb25Qcm9ncmFtIiwiZGl2ZXJnZW5jZVByb2dyYW0iLCJjdXJsUHJvZ3JhbSIsInZvcnRpY2l0eVByb2dyYW0iLCJwcmVzc3VyZVByb2dyYW0iLCJncmFkaWVuU3VidHJhY3RQcm9ncmFtIiwiZGlzcGxheU1hdGVyaWFsIiwiaW5pdEZyYW1lYnVmZmVycyIsInNpbVJlcyIsImR5ZVJlcyIsInRleFR5cGUiLCJyZ2JhIiwicmciLCJmaWx0ZXJpbmciLCJMSU5FQVIiLCJkaXNhYmxlIiwiQkxFTkQiLCJjcmVhdGVEb3VibGVGQk8iLCJyZXNpemVEb3VibGVGQk8iLCJpbml0Qmxvb21GcmFtZWJ1ZmZlcnMiLCJpbml0U3VucmF5c0ZyYW1lYnVmZmVycyIsInciLCJoIiwicGFyYW0iLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ0ZXhlbFNpemVYIiwidGV4ZWxTaXplWSIsImF0dGFjaCIsImZibzEiLCJmYm8yIiwicmVhZCIsInZhbHVlIiwid3JpdGUiLCJzd2FwIiwidGVtcCIsInJlc2l6ZUZCTyIsIm5ld0ZCTyIsInVuaWZvcm0xaSIsInVUZXh0dXJlIiwidXJsIiwiUkVQRUFUIiwiUkdCIiwiVU5TSUdORURfQllURSIsIm9iaiIsImltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJzcmMiLCJ1cGRhdGVLZXl3b3JkcyIsImRpc3BsYXlLZXl3b3JkcyIsIm11bHRpcGxlU3BsYXRzIiwicGFyc2VJbnQiLCJyYW5kb20iLCJsYXN0VXBkYXRlVGltZSIsIkRhdGUiLCJub3ciLCJjb2xvclVwZGF0ZVRpbWVyIiwidXBkYXRlIiwiZHQiLCJjYWxjRGVsdGFUaW1lIiwidXBkYXRlQ29sb3JzIiwiYXBwbHlJbnB1dHMiLCJzdGVwIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2NhbGVCeVBpeGVsUmF0aW8iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIndyYXAiLCJwIiwiZ2VuZXJhdGVDb2xvciIsInBvcCIsInNwbGF0UG9pbnRlciIsInVuaWZvcm0yZiIsInRleGVsU2l6ZSIsInVWZWxvY2l0eSIsInVDdXJsIiwidW5pZm9ybTFmIiwidURpdmVyZ2VuY2UiLCJ1UHJlc3N1cmUiLCJkeWVUZXhlbFNpemUiLCJ2ZWxvY2l0eUlkIiwidVNvdXJjZSIsImRpc3NpcGF0aW9uIiwiYXBwbHlCbG9vbSIsImFwcGx5U3VucmF5cyIsImJsdXIiLCJibGVuZEZ1bmMiLCJPTkUiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiZW5hYmxlIiwiZHJhd0NvbG9yIiwibm9ybWFsaXplQ29sb3IiLCJkcmF3Q2hlY2tlcmJvYXJkIiwiZHJhd0Rpc3BsYXkiLCJ1bmlmb3JtNGYiLCJhc3BlY3RSYXRpbyIsInVCbG9vbSIsInVEaXRoZXJpbmciLCJzY2FsZSIsImdldFRleHR1cmVTY2FsZSIsImRpdGhlclNjYWxlIiwieCIsInkiLCJ1U3VucmF5cyIsImRlc3RpbmF0aW9uIiwibGFzdCIsImtuZWUiLCJjdXJ2ZTAiLCJjdXJ2ZTEiLCJjdXJ2ZTIiLCJ1bmlmb3JtM2YiLCJjdXJ2ZSIsInRocmVzaG9sZCIsImRlc3QiLCJiYXNlVGV4IiwiaW50ZW5zaXR5IiwibWFzayIsIndlaWdodCIsIml0ZXJhdGlvbnMiLCJwb2ludGVyIiwiZHgiLCJkeSIsInNwbGF0IiwiYW1vdW50IiwidVRhcmdldCIsInBvaW50IiwicmFkaXVzIiwiY29ycmVjdFJhZGl1cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicG9zWCIsIm9mZnNldFgiLCJwb3NZIiwib2Zmc2V0WSIsImZpbmQiLCJ1cGRhdGVQb2ludGVyRG93bkRhdGEiLCJ1cGRhdGVQb2ludGVyTW92ZURhdGEiLCJ1cGRhdGVQb2ludGVyVXBEYXRhIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJpZGVudGlmaWVyIiwiY2hhbmdlZFRvdWNoZXMiLCJjb2RlIiwia2V5IiwiY29ycmVjdERlbHRhWCIsImNvcnJlY3REZWx0YVkiLCJhYnMiLCJkZWx0YSIsImMiLCJIU1Z0b1JHQiIsInMiLCJ2IiwiZiIsInEiLCJ0IiwiZmxvb3IiLCJvdXRwdXQiLCJyYW5nZSIsInJlc29sdXRpb24iLCJyb3VuZCIsInBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwiY2hhckNvZGVBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./shared/lib/webgl.js\n"));

/***/ })

});